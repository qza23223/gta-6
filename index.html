<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sunset City - Vice Remastered</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* UI LAYERS */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 28px; color: #ff00de; font-style: italic; letter-spacing: 2px; text-transform: uppercase; }
        .hud-text { font-size: 14px; color: #00f7ff; font-weight: bold; }

        /* WANTED STARS */
        #wanted-stars {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }
        .wanted-star {
            width: 32px;
            height: 32px;
            position: relative;
        }
        .wanted-star svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
        }
        .wanted-star .star-fill {
            fill: #555;
            transition: fill 0.3s ease;
        }
        .wanted-star .star-stroke {
            fill: none;
            stroke: #000;
            stroke-width: 2;
        }
        .wanted-star.active .star-fill {
            fill: #fff;
        }
        .wanted-star.active {
            animation: starPulse 0.5s ease-out;
        }
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* CASH DISPLAY */
        #cash-display {
            position: absolute;
            top: 55px;
            right: 20px;
            color: #4cff4c;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
            font-family: 'Pricedown', 'Impact', sans-serif;
            letter-spacing: 1px;
            z-index: 10;
        }

        /* PHONE UI */
        #phone-container {
            position: absolute;
            bottom: -600px; /* Hidden */
            right: 30px;
            width: 280px;
            height: 550px;
            background: #111;
            border-radius: 30px;
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            transition: bottom 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }
        #phone-container.active { bottom: 30px; }
        
        .phone-header {
            height: 30px;
            background: #000;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            font-size: 12px;
        }
        .phone-screen {
            flex: 1;
            background: linear-gradient(135deg, #ff00de, #00f7ff);
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 15px;
            align-content: start;
            position: relative;
        }
        .app-icon {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .app-icon:hover { transform: scale(1.1); }
        .app-label {
            grid-column: span 3;
            text-align: center;
            color: white;
            margin-top: 50px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        
        /* CROSSHAIR */
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none; /* Hidden by default */
            z-index: 50;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 2px black;
        }
        
        #crosshair::before {
            top: 9px; left: 0; width: 20px; height: 2px;
        }
        
        #crosshair::after {
            top: 0; left: 9px; width: 2px; height: 20px;
        }

        /* LOADING */
        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 1s;
        }
        .loader-text { color: #ff00de; font-size: 24px; font-style: italic; margin-bottom: 20px; }
        .loader-bar { width: 200px; height: 4px; background: #333; }
        .loader-fill { width: 0%; height: 100%; background: #00f7ff; transition: width 0.5s; }

        /* HOTWIRE UI */
        #hotwire-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ff00de;
            color: white;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        #hotwire-progress {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        #hotwire-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff00de, #00f7ff);
            width: 0%;
            transition: width 0.1s;
        }

        /* ENTER PROMPT */
        #enter-prompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
            z-index: 1000;
            border: 1px solid #00f7ff;
        }

        /* NPC INTERACTION UI */
        #npc-interact-prompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
            z-index: 1000;
            border: 1px solid #ff00de;
        }

        #npc-interaction-menu {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 0;
            border-radius: 12px;
            border: 2px solid #ff00de;
            display: none;
            z-index: 1001;
            overflow: hidden;
            min-width: 200px;
            box-shadow: 0 0 30px rgba(255, 0, 222, 0.3);
        }

        .interact-option {
            padding: 15px 25px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .interact-option:last-child {
            border-bottom: none;
        }

        .interact-option:hover {
            background: rgba(255, 0, 222, 0.3);
        }

        .interact-option.greet {
            color: #00ff88;
        }

        .interact-option.greet:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .interact-option.threaten {
            color: #ff4444;
        }

        .interact-option.threaten:hover {
            background: rgba(255, 68, 68, 0.2);
        }

        .interact-option.hit {
            color: #ff8800;
        }

        .interact-option.hit:hover {
            background: rgba(255, 136, 0, 0.2);
        }

        .interact-option .key-hint {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: auto;
        }

        /* NPC Fear Indicator */
        .npc-fear-bar {
            position: absolute;
            width: 50px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            pointer-events: none;
        }

        .npc-fear-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ffff00, #ff4444);
            transition: width 0.3s;
        }

        /* Floating Text */
        .floating-text {
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            animation: floatUp 1.5s ease-out forwards;
            z-index: 1002;
        }

        .floating-text.greet {
            color: #00ff88;
        }

        .floating-text.threaten {
            color: #ff4444;
        }

        .floating-text.scream {
            color: #ff00de;
            font-size: 18px;
        }
        
        .floating-text.damage {
            color: #ffaa00;
            font-size: 20px;
            font-family: 'Courier New', monospace;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(-50%);
            }
            100% {
                opacity: 0;
                transform: translateY(-60px) translateX(-50%);
            }
        }

        /* === GTA-STYLE MINIMAP === */
        #minimap-container {
            position: absolute;
            bottom: 25px;
            left: 20px;
            width: 200px;
            height: 220px;
            background: transparent;
            z-index: 10;
            overflow: visible;
        }
        
        #minimap-frame {
            position: absolute;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: linear-gradient(145deg, #1a2a3a, #0d1520);
            box-shadow: 
                0 0 0 3px #0a1015,
                0 0 0 6px rgba(0, 200, 255, 0.4),
                inset 0 0 30px rgba(0, 0, 0, 0.8),
                0 6px 20px rgba(0, 0, 0, 0.6);
            overflow: hidden;
        }
        
        #minimap-canvas {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            display: block;
        }
        
        #minimap-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 60%, rgba(0, 15, 25, 0.6) 100%);
            box-shadow: inset 0 0 20px rgba(0, 200, 255, 0.15);
        }
        
        #minimap-compass {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            color: #00d4ff;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 212, 255, 0.8);
            letter-spacing: 2px;
        }
        
        #minimap-location {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 3px #000;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 8px;
            border-radius: 3px;
        }
        
        #health-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 20px;
            background: #333;
            border: 2px solid #ff00de;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            width: 100%;
            transition: width 0.3s;
        }
        
        .police-siren-flash {
            animation: sirenFlash 0.5s infinite alternate;
        }
        
        @keyframes sirenFlash {
            0% { opacity: 0.8; }
            100% { opacity: 0.2; }
        }

        /* === GTA-STYLE WEAPON WHEEL === */
        #inventory-wheel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            height: 350px;
            background: radial-gradient(circle, rgba(20, 20, 30, 0.95) 0%, rgba(10, 10, 15, 0.98) 100%);
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 0 60px rgba(0, 0, 0, 0.8),
                inset 0 0 80px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(100, 200, 255, 0.2);
            display: none;
            z-index: 1000;
            pointer-events: auto;
        }

        #inventory-wheel::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, rgba(40, 40, 50, 0.9) 0%, rgba(20, 20, 25, 0.95) 100%);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #inventory-wheel::after {
            content: 'WEAPONS';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .inventory-item {
            position: absolute;
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, rgba(50, 50, 60, 0.8), rgba(30, 30, 40, 0.9));
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            color: white;
            cursor: pointer;
            transition: all 0.15s ease-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .inventory-item::after {
            content: attr(data-name);
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .inventory-item:hover {
            background: linear-gradient(145deg, rgba(80, 80, 100, 0.9), rgba(50, 50, 70, 0.95));
            border-color: rgba(100, 200, 255, 0.5);
            transform: scale(1.15);
            box-shadow: 0 6px 25px rgba(100, 200, 255, 0.3);
        }

        .inventory-item.selected {
            border: 2px solid #00d4ff;
            background: linear-gradient(145deg, rgba(0, 100, 150, 0.6), rgba(0, 60, 100, 0.7));
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        #ammo-display {
            position: absolute;
            bottom: 50px;
            right: 20px;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            display: none;
            text-shadow: 1px 1px 2px #000;
        }

    </style>
</head>
<body>

    <!-- === GTA-STYLE MINIMAP & HEALTH UI === -->
    <div id="minimap-container">
        <div id="minimap-compass">N</div>
        <div id="minimap-frame">
        <canvas id="minimap-canvas"></canvas>
            <div id="minimap-overlay"></div>
        </div>
        <div id="minimap-location">DOWNTOWN</div>
    </div>
    
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>

    <!-- [All your original UI remains unchanged] -->
    <div id="ui-layer">
        <h1>SUNSET CITY</h1>
        <div class="hud-text" id="clock">12:00 PM</div>
        <div class="hud-text" id="vehicle-hud" style="display: none;">
            Vehicle: <span id="vehicle-name"></span> | Speed: <span id="vehicle-speed">0</span> mph
        </div>
        <div class="hud-text" id="current-weapon-hud">Weapon: Fists</div>
    </div>
    
    <div id="ammo-display">‚àû / ‚àû</div>

    <div id="wanted-stars">
        <div class="wanted-star" data-star="1">
            <svg viewBox="0 0 24 24">
                <polygon class="star-fill" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
                <polygon class="star-stroke" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
            </svg>
        </div>
        <div class="wanted-star" data-star="2">
            <svg viewBox="0 0 24 24">
                <polygon class="star-fill" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
                <polygon class="star-stroke" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
            </svg>
        </div>
        <div class="wanted-star" data-star="3">
            <svg viewBox="0 0 24 24">
                <polygon class="star-fill" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
                <polygon class="star-stroke" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
            </svg>
        </div>
        <div class="wanted-star" data-star="4">
            <svg viewBox="0 0 24 24">
                <polygon class="star-fill" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
                <polygon class="star-stroke" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
            </svg>
        </div>
        <div class="wanted-star" data-star="5">
            <svg viewBox="0 0 24 24">
                <polygon class="star-fill" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
                <polygon class="star-stroke" points="12,2 15,9 22,9 17,14 19,22 12,17 5,22 7,14 2,9 9,9"/>
            </svg>
        </div>
    </div>

    <div id="cash-display">$0</div>

    <div id="crosshair"></div>

    <div id="hotwire-ui">
        <div>HOTWIRING VEHICLE...</div>
        <div id="hotwire-progress">
            <div id="hotwire-progress-fill"></div>
        </div>
        <div style="font-size: 12px; margin-top: 10px; color: #00f7ff;">Hold E to continue</div>
    </div>

    <div id="enter-prompt">
        Press <span style="color: #00f7ff;">E</span> to enter vehicle
    </div>

    <div id="npc-interact-prompt">
        Press <span style="color: #ff00de;">E</span> to interact
    </div>

    <div id="npc-interaction-menu">
        <div class="interact-option greet" onclick="handleInteraction('greet')">
            <span>üëã</span>
            <span>Greet</span>
            <span class="key-hint">1</span>
        </div>
        <div class="interact-option threaten" onclick="handleInteraction('threaten')">
            <span>üò†</span>
            <span>Threaten</span>
            <span class="key-hint">2</span>
        </div>
        <div class="interact-option hit" onclick="handleInteraction('hit')">
            <span>üëä</span>
            <span>Hit</span>
            <span class="key-hint">3</span>
        </div>
    </div>

    <div id="phone-container">
        <div class="phone-header">
            <span>9:41</span>
            <span>üîã 100%</span>
        </div>
        <div class="phone-screen">
            <div class="app-icon" onclick="openApp('TokTik')" style="background: #000; color: #fff;">üéµ</div>
            <div class="app-icon" onclick="openApp('Insta')" style="background: radial-gradient(circle at 30% 107%, #fdf497 0%, #fdf497 5%, #fd5949 45%, #d6249f 60%, #285AEB 90%); color: white;">üì∑</div>
            <div class="app-icon" onclick="openApp('Tube')" style="background: #f00; color: white;">‚ñ∂Ô∏è</div>
            <div class="app-icon" onclick="openApp('Maps')" style="background: #3e9c35; color: white;">üó∫Ô∏è</div>
            
            <div id="app-display" class="app-label">Select an App</div>
        </div>
    </div>

    <div id="loading">
        <div class="loader-text">GENERATING TEXTURES...</div>
        <div class="loader-bar"><div class="loader-fill" id="loader-fill"></div></div>
    </div>

    <!-- === NEW INVENTORY WHEEL === -->
    <div id="inventory-wheel"></div>

    <!-- CANVAS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            gridSize: 20, // Reduced from 24
            tileSize: 25,
            buildingHeightMin: 15,
            buildingHeightMax: 50, // Reduced max height
            roadWidth: 14,
            walkSpeed: 0.08,
            runSpeed: 0.18,
            maxCars: 8, // Reduced from 15
            trafficLightsCount: 4, // Reduced
            enterDistance: 3,
            hotwireTime: 2000,
            npcInteractDistance: 4,
            fearPropagationRadius: 15,
            fearPropagationAmount: 25,
            
            // === NEW POLICE CONFIG ===
            playerHealth: 100,
            maxHealth: 100,
            policeSpawnDelay: 3000,
            policePursueDistance: 100,
            policeShootingDistance: 25,
            policeYellingDistance: 30,
            policeHelicopterAltitude: 40,
            policeMaxSearchTime: {
                1: 30,    // 30 seconds
                2: 120,   // 2 minutes
                3: 240,   // 4 minutes
                4: 900,   // 15 minutes
                5: Infinity // Never give up
            }
        };

        const WEAPON_STATS = {
            'Fists': { damage: 5, range: 2, fireRate: 500, type: 'melee' },
            'Baseball Bat': { damage: 15, range: 3, fireRate: 800, type: 'melee' },
            'Pistol': { damage: 15, range: 80, fireRate: 300, type: 'gun', automatic: false, color: 0x333333 },
            'AK-47': { damage: 25, range: 120, fireRate: 100, type: 'gun', automatic: true, color: 0x8B4513 }
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let playerGroup, playerMesh, playerHead, playerArm, playerGun;
        let playerLeftLeg, playerRightLeg, playerLeftArm, playerTorso;
        let playerAnimTime = 0;
        let playerIsMoving = false;
        let playerIsSprinting = false;
        let cameraMode = 'third';
        let isPhoneOpen = false;
        let isInVehicle = false;
        let currentVehicle = null;
        let isHotwiring = false;
        let hotwireStartTime = 0;
        let sunMesh;
        
        // NPC Interaction
        let isInteractingWithNPC = false;
        let currentInteractNPC = null;
        
        // Wanted Level System
        let wantedLevel = 0;
        const MAX_WANTED_LEVEL = 5;
        
        // === NEW POLICE GLOBALS ===
        let playerHealth = CONFIG.playerHealth;
        let playerCash = 0;
        let policeCars = [];
        let policeHelicopters = [];
        let lastPoliceSpawn = 0;
        let policeYellIndex = 0;

        // Shooting globals
        let raycaster;
        let bullets = [];
        let explosions = [];
        let isMouseDown = false;
        let lastFireTime = 0;
        
        const POLICE_YELLS = [
            "Stop right there!",
            "You're under arrest!",
            "Get on the ground now!",
            "Police! Don't move!",
            "Surrender immediately!",
            "This is your final warning!",
            "Stop or we'll shoot!",
            "Hands in the air!"
        ];
        
        // Input
        const keys = { w: false, a: false, s: false, d: false, shift: false, space: false, e: false, f: false, q: false };
        let mouseX = 0, mouseY = 0;
        let pitch = 0, yaw = Math.PI;
        
        // Noclip / Cinematic Camera Mode
        let isNoclipMode = false;
        let noclipSpeed = 0; // 0 = off, 1 = slow, 2 = ultra slow
        let noclipPosition = new THREE.Vector3();
        let noclipTargetYaw = 0;
        let noclipTargetPitch = 0;
        let noclipCurrentYaw = 0;
        let noclipCurrentPitch = 0;
        let lastXPress = 0;

        // World Data
        let worldGrid = [];
        let buildings = [];
        let trafficLights = [];
        let cars = [];
        let npcs = [];
        let roadTiles = [];

        // Scream sounds (text representations)
        const SCREAM_TEXTS = [
            "AAAAHHH!", "HELP!", "OH NO!", "RUN!", 
            "SOMEONE HELP!", "STAY AWAY!", "NOOO!", "EEEK!"
        ];

        const GREET_TEXTS = [
            "Hey there!", "Hello!", "Nice day!", "Hi!", 
            "How's it going?", "Howdy!", "What's up?"
        ];

        const THREATEN_RESPONSES = [
            "Please don't!", "Leave me alone!", "What do you want?!",
            "Back off!", "I don't want trouble!", "Stay back!"
        ];

        // Car Types - More realistic proportions
        const CAR_TYPES = {
            SPORTS: {
                name: "Sports Car",
                speed: 0.5,
                acceleration: 0.025,
                handling: 0.035,
                colors: [0xcc0000, 0x0044cc, 0xffcc00, 0xff00aa, 0x00cccc, 0x00cc00]
            },
            MUSCLE: {
                name: "Muscle Car",
                speed: 0.45,
                acceleration: 0.03,
                handling: 0.025,
                colors: [0x111111, 0x880000, 0x004488, 0xff6600, 0x228822]
            },
            SEDAN: {
                name: "Sedan",
                speed: 0.3,
                acceleration: 0.018,
                handling: 0.028,
                colors: [0xeeeeee, 0x888888, 0x444444, 0x222222, 0x1a3366, 0x663322]
            },
            SUV: {
                name: "SUV",
                speed: 0.28,
                acceleration: 0.015,
                handling: 0.022,
                colors: [0x222222, 0x333333, 0x555555, 0x1a1a44, 0x2a1a1a]
            },
            COUPE: {
                name: "Coupe",
                speed: 0.38,
                acceleration: 0.022,
                handling: 0.03,
                colors: [0xffffff, 0xcc0000, 0x0066cc, 0x333333, 0xffaa00]
            }
        };

        // --- ENHANCED TEXTURE GENERATOR ---
        function createTexture(type, size = 512) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            if (type === 'road') {
                // Realistic asphalt with subtle variation
                const gradient = ctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, '#2a2a2a');
                gradient.addColorStop(0.5, '#1f1f1f');
                gradient.addColorStop(1, '#252525');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                
                // Asphalt texture noise
                for(let i = 0; i < 30000; i++) {
                    const gray = 20 + Math.random() * 35;
                    ctx.fillStyle = `rgba(${gray},${gray},${gray}, 0.5)`;
                    ctx.fillRect(Math.random()*size, Math.random()*size, 1 + Math.random()*2, 1 + Math.random()*2);
                }
                
                // Subtle oil stains
                for(let i = 0; i < 5; i++) {
                    ctx.fillStyle = `rgba(30, 25, 20, 0.3)`;
                    ctx.beginPath();
                    ctx.ellipse(Math.random()*size, Math.random()*size, 10 + Math.random()*20, 5 + Math.random()*10, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Yellow center line markings
                ctx.fillStyle = '#e6b800';
                ctx.shadowColor = '#ccaa00';
                ctx.shadowBlur = 2;
                ctx.fillRect(size/2 - 3, 0, 2.5, size);
                ctx.fillRect(size/2 + 1, 0, 2.5, size);
                ctx.shadowBlur = 0;
                
            } else if (type === 'building') {
                // Modern building facade with windows
                ctx.fillStyle = '#404550';
                ctx.fillRect(0, 0, size, size);
                
                // Window grid
                const windowWidth = 50;
                const windowHeight = 60;
                const spacing = 64;
                
                for(let i = 6; i < size; i += spacing) {
                    for(let j = 6; j < size; j += spacing) {
                        // Window frame
                        ctx.fillStyle = '#2a2e35';
                        ctx.fillRect(i, j, windowWidth + 4, windowHeight + 4);
                        
                        // Window glass with reflection effect
                        const glassGrad = ctx.createLinearGradient(i, j, i + windowWidth, j + windowHeight);
                        const lit = Math.random() > 0.7;
                        if (lit) {
                            glassGrad.addColorStop(0, '#ffe066');
                            glassGrad.addColorStop(1, '#ffcc00');
                        } else {
                            glassGrad.addColorStop(0, '#1a3040');
                            glassGrad.addColorStop(0.3, '#0d1820');
                            glassGrad.addColorStop(0.7, '#152535');
                            glassGrad.addColorStop(1, '#0a1520');
                        }
                        ctx.fillStyle = glassGrad;
                        ctx.fillRect(i + 2, j + 2, windowWidth, windowHeight);
                        
                        // Window reflection highlight
                        if (!lit) {
                            ctx.fillStyle = 'rgba(100, 150, 200, 0.15)';
                            ctx.fillRect(i + 2, j + 2, windowWidth * 0.4, windowHeight * 0.3);
                        }
                    }
                }
                
                // Building panels/seams
                ctx.strokeStyle = '#35393f';
                ctx.lineWidth = 1;
                for(let i = 0; i < size; i += spacing * 2) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, size);
                    ctx.stroke();
                }
                
            } else if (type === 'sand') {
                // Realistic beach sand
                const sandGrad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size);
                sandGrad.addColorStop(0, '#f5e6c8');
                sandGrad.addColorStop(1, '#e8d4a8');
                ctx.fillStyle = sandGrad;
                ctx.fillRect(0, 0, size, size);
                
                // Sand grain texture
                for(let i = 0; i < 15000; i++) {
                    const colors = ['#f0ddb5', '#e5cca0', '#f8edd5', '#d9c090', '#f2e2c0'];
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.fillRect(Math.random()*size, Math.random()*size, 1 + Math.random()*2, 1 + Math.random()*2);
                }
                
                // Occasional shells/pebbles
                for(let i = 0; i < 8; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#c0b0a0' : '#d0c8c0';
                    ctx.beginPath();
                    ctx.ellipse(Math.random()*size, Math.random()*size, 3 + Math.random()*4, 2 + Math.random()*3, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
                
            } else if (type === 'rubber') {
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, size, size);
                
                // Tire tread pattern
                for(let i = 0; i < size; i += 20) {
                    ctx.fillStyle = '#151515';
                    ctx.fillRect(0, i, size, 8);
                }
                for(let i = 0; i < 8000; i++) {
                    ctx.fillStyle = `rgba(25, 25, 25, 0.5)`;
                    ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
                }
                
            } else if (type === 'glass') {
                // Reflective glass
                const gradient = ctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, '#0a1825');
                gradient.addColorStop(0.3, '#152535');
                gradient.addColorStop(0.6, '#0d1a28');
                gradient.addColorStop(1, '#1a2a3a');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                
                // Reflection highlight
                ctx.fillStyle = 'rgba(150, 180, 200, 0.1)';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(size * 0.4, 0);
                ctx.lineTo(0, size * 0.4);
                ctx.closePath();
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 4;
            return tex;
        }

        const textures = {};

        // --- INITIALIZATION ---
        function init() {
            // Loading UI
            document.getElementById('loader-fill').style.width = '50%';
            
            // Generate Textures
            textures.road = createTexture('road');
            textures.building = createTexture('building');
            textures.sand = createTexture('sand');
            textures.rubber = createTexture('rubber');
            textures.glass = createTexture('glass');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background to prevent black areas
            
            // ENHANCED SKY
            createSky();

            // Atmospheric fog for depth and realism
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.0008);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.5, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, // Re-enabled for better visuals
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Balanced
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap; // Better quality shadows
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            // ENHANCED LIGHTING SETUP
            // Hemisphere light (sky/ground ambient)
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x5a7247, 0.7);
            scene.add(hemiLight);

            // Main sun directional light - Balanced
            const dirLight = new THREE.DirectionalLight(0xfff5e6, 1.4);
            dirLight.position.set(150, 250, -100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 10;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.bias = -0.0005;
            const shadowSize = 250;
            dirLight.shadow.camera.left = -shadowSize;
            dirLight.shadow.camera.right = shadowSize;
            dirLight.shadow.camera.top = shadowSize;
            dirLight.shadow.camera.bottom = -shadowSize;
            scene.add(dirLight);
            
            // Ambient and fill lights for better scene lighting
            const ambientLight = new THREE.AmbientLight(0x6090b0, 0.5);
            scene.add(ambientLight);
            
            const fillLight = new THREE.DirectionalLight(0x88aacc, 0.3);
            fillLight.position.set(-80, 100, 80);
            scene.add(fillLight);

            // Level Gen
            generateCityGrid();
            createMountains(); 
            
            // Player
            createPlayer();

            // Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', () => { 
                if(!isPhoneOpen && !isInventoryOpen) {
                    isMouseDown = true; 
                    if(!isInteractingWithNPC && !isInVehicle) document.body.requestPointerLock();
                }
            });
            document.addEventListener('mouseup', () => { isMouseDown = false; });
            window.addEventListener('resize', onWindowResize);

            // Finish Loading
            document.getElementById('loader-fill').style.width = '100%';
            setTimeout(() => {
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').remove(), 1000);
            }, 500);

            // Initialize inventory
            initInventory();

            animate();
        }

        // ENHANCED REALISTIC SKY
        function createSky() {
            // Gradient Sky Sphere with atmospheric scattering effect
            const vertexShader = `
                varying vec3 vWorldPosition;
                varying vec3 vSunDirection;
                uniform vec3 sunPosition;
                
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldPosition = worldPosition.xyz;
                    vSunDirection = normalize(sunPosition);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `;
            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 horizonColor;
                uniform vec3 bottomColor;
                uniform vec3 sunPosition;
                uniform float sunIntensity;
                varying vec3 vWorldPosition;
                varying vec3 vSunDirection;
                
                void main() {
                    vec3 direction = normalize(vWorldPosition);
                    float h = direction.y;
                    
                    // Multi-stop gradient for realistic sky
                    vec3 skyColor;
                    if (h > 0.0) {
                        // Above horizon
                        float t = pow(h, 0.4);
                        skyColor = mix(horizonColor, topColor, t);
                    } else {
                        // Below horizon (ground reflection tint)
                        skyColor = mix(horizonColor, bottomColor, pow(-h, 0.5));
                    }
                    
                    // Sun glow effect
                    float sunDot = max(dot(direction, vSunDirection), 0.0);
                    vec3 sunGlow = vec3(1.0, 0.9, 0.7) * pow(sunDot, 8.0) * 0.5;
                    vec3 sunCore = vec3(1.0, 0.95, 0.8) * pow(sunDot, 256.0) * sunIntensity;
                    
                    // Atmospheric haze near horizon
                    float haze = 1.0 - abs(h);
                    haze = pow(haze, 3.0) * 0.3;
                    vec3 hazeColor = vec3(0.9, 0.85, 0.8);
                    
                    skyColor = mix(skyColor, hazeColor, haze);
                    skyColor += sunGlow + sunCore;
                    
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            `;
            const uniforms = {
                topColor: { value: new THREE.Color(0x1e90ff) },      // Deep sky blue
                horizonColor: { value: new THREE.Color(0x87ceeb) },  // Light sky blue
                bottomColor: { value: new THREE.Color(0x4a6741) },   // Ground tint
                sunPosition: { value: new THREE.Vector3(100, 400, -200) },
                sunIntensity: { value: 2.0 }
            };
            const skyGeo = new THREE.SphereGeometry(600, 32, 24); // Within camera range
            const skyMat = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);

            // Simplified sun
            const sunGeo = new THREE.SphereGeometry(25, 12, 8);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffffdd });
            sunMesh = new THREE.Mesh(sunGeo, sunMat);
            sunMesh.position.set(100, 350, -200);
            scene.add(sunMesh);
            
            // Add some clouds
            createClouds();
        }
        
        // REALISTIC CLOUDS - Balanced for performance
        function createClouds() {
            const cloudGroup = new THREE.Group();
            const cloudMat = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            
            // Create 12 fluffy cloud formations
            for (let i = 0; i < 12; i++) {
                const cloud = new THREE.Group();
                const numPuffs = 3 + Math.floor(Math.random() * 4); // 3-6 puffs per cloud
                
                for (let j = 0; j < numPuffs; j++) {
                    const size = 15 + Math.random() * 30;
                    const puffGeo = new THREE.SphereGeometry(size, 6, 5);
                    const puff = new THREE.Mesh(puffGeo, cloudMat);
                    puff.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 12,
                        (Math.random() - 0.5) * 40
                    );
                    puff.scale.y = 0.5 + Math.random() * 0.3;
                    cloud.add(puff);
                }
                
                cloud.position.set(
                    (Math.random() - 0.3) * worldSize * 2.5,
                    160 + Math.random() * 120,
                    (Math.random() - 0.5) * worldSize * 2.5
                );
                
                cloudGroup.add(cloud);
            }
            
            scene.add(cloudGroup);
        }

        // DISTINCT MOUNTAIN PEAKS - Separate mountains around the map
        function createMountains() {
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            const mountainGroup = new THREE.Group();
            
            // Mountain material with better texturing - DoubleSide to fix see-through
            const createMountainMaterial = (baseColor) => {
                return new THREE.MeshStandardMaterial({
                    color: baseColor,
                    roughness: 0.9,
                    metalness: 0.1,
                    flatShading: true,
                    side: THREE.DoubleSide
                });
            };
            
            // Snow cap material
            const snowMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.8,
                metalness: 0.0,
                side: THREE.DoubleSide
            });
            
            // Function to create a single mountain peak
            function createMountainPeak(x, z, height, baseRadius, rockColor) {
                const peakGroup = new THREE.Group();
                
                // Main mountain cone with some irregularity
                const segments = 8 + Math.floor(Math.random() * 4);
                const coneGeo = new THREE.ConeGeometry(baseRadius, height, segments);
                
                // Add some vertex noise for natural look
                const pos = coneGeo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const y = pos.getY(i);
                    // Don't modify the tip too much
                    if (y < height * 0.85) {
                        const noise = (Math.random() - 0.5) * baseRadius * 0.3;
                        pos.setX(i, pos.getX(i) + noise * (1 - y / height));
                        pos.setZ(i, pos.getZ(i) + noise * (1 - y / height));
                    }
                }
                coneGeo.computeVertexNormals();
                
                const coneMat = createMountainMaterial(rockColor);
                const cone = new THREE.Mesh(coneGeo, coneMat);
                cone.position.y = height / 2;
                cone.castShadow = true;
                cone.receiveShadow = true;
                peakGroup.add(cone);
                
                // Snow cap on tall mountains
                if (height > 60) {
                    const snowCapGeo = new THREE.ConeGeometry(baseRadius * 0.35, height * 0.25, segments);
                    const snowCap = new THREE.Mesh(snowCapGeo, snowMat);
                    snowCap.position.y = height * 0.88;
                    snowCap.castShadow = true;
                    peakGroup.add(snowCap);
                }
                
                // Add rocky base/foothills
                const baseGeo = new THREE.ConeGeometry(baseRadius * 1.4, height * 0.3, segments + 2);
                const basePos = baseGeo.attributes.position;
                for (let i = 0; i < basePos.count; i++) {
                    const noise = (Math.random() - 0.5) * baseRadius * 0.4;
                    basePos.setX(i, basePos.getX(i) + noise);
                    basePos.setZ(i, basePos.getZ(i) + noise);
                }
                baseGeo.computeVertexNormals();
                
                const baseMat = createMountainMaterial(0x4a3d31);
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = height * 0.1;
                base.receiveShadow = true;
                peakGroup.add(base);
                
                peakGroup.position.set(x, 0, z);
                return peakGroup;
            }
            
            // Mountain color palette
            const rockColors = [0x5a4d41, 0x6b5c4a, 0x4d4035, 0x635545, 0x524538];
            
            // Define mountain positions around map edges (except beach side which is +X)
            const mountainPositions = [
                // North side (behind the city, -Z direction)
                { x: worldSize * 0.1, z: -80, h: 95, r: 55 },
                { x: worldSize * 0.25, z: -60, h: 120, r: 70 },
                { x: worldSize * 0.4, z: -90, h: 85, r: 50 },
                { x: worldSize * 0.55, z: -70, h: 105, r: 60 },
                { x: worldSize * 0.7, z: -85, h: 75, r: 45 },
                
                // Northwest corner
                { x: -60, z: -50, h: 130, r: 75 },
                { x: -40, z: -80, h: 90, r: 50 },
                
                // West side (-X direction)
                { x: -70, z: worldSize * 0.1, h: 100, r: 60 },
                { x: -90, z: worldSize * 0.25, h: 140, r: 80 },
                { x: -60, z: worldSize * 0.4, h: 110, r: 65 },
                { x: -80, z: worldSize * 0.55, h: 125, r: 70 },
                { x: -55, z: worldSize * 0.7, h: 95, r: 55 },
                { x: -75, z: worldSize * 0.85, h: 115, r: 65 },
                
                // Southwest corner
                { x: -50, z: worldSize + 50, h: 105, r: 60 },
                { x: -70, z: worldSize + 30, h: 85, r: 50 },
                
                // South side (+Z direction) - partial, leaving space near beach
                { x: worldSize * 0.1, z: worldSize + 60, h: 110, r: 65 },
                { x: worldSize * 0.25, z: worldSize + 80, h: 135, r: 75 },
                { x: worldSize * 0.4, z: worldSize + 55, h: 90, r: 55 },
                
                // Additional background mountains (further away, larger)
                { x: -150, z: worldSize * 0.3, h: 180, r: 100 },
                { x: -130, z: worldSize * 0.6, h: 160, r: 90 },
                { x: worldSize * 0.2, z: -150, h: 170, r: 95 },
                { x: worldSize * 0.5, z: -140, h: 145, r: 85 },
            ];
            
            // Create each mountain peak
            mountainPositions.forEach(pos => {
                const colorIdx = Math.floor(Math.random() * rockColors.length);
                const peak = createMountainPeak(
                    pos.x, 
                    pos.z, 
                    pos.h + (Math.random() - 0.5) * 20, 
                    pos.r + (Math.random() - 0.5) * 15,
                    rockColors[colorIdx]
                );
                mountainGroup.add(peak);
            });
            
            scene.add(mountainGroup);
        }

        // DYNAMIC OCEAN with animated waves
        let oceanMesh, oceanUniforms;
        function createOcean() {
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            const beachEdgeX = worldSize + 5;
            
            // Main ocean with shader for waves
            const oceanGeo = new THREE.PlaneGeometry(600, worldSize * 1.5, 48, 48);
            
            const oceanVertexShader = `
                uniform float time;
                varying vec2 vUv;
                varying float vWaveHeight;
                
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    
                    // Multiple wave layers for realistic motion
                    float wave1 = sin(pos.x * 0.08 + time * 1.2) * cos(pos.y * 0.05 + time * 0.8) * 1.2;
                    float wave2 = sin(pos.x * 0.15 + time * 1.8) * cos(pos.y * 0.1 + time * 1.1) * 0.6;
                    float wave3 = sin(pos.x * 0.25 + pos.y * 0.2 + time * 2.0) * 0.3;
                    
                    pos.z = wave1 + wave2 + wave3;
                    vWaveHeight = pos.z;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;
            
            const oceanFragmentShader = `
                uniform float time;
                varying vec2 vUv;
                varying float vWaveHeight;
                
                void main() {
                    // Deep to shallow gradient
                    vec3 deepColor = vec3(0.0, 0.25, 0.5);
                    vec3 shallowColor = vec3(0.1, 0.6, 0.7);
                    vec3 foamColor = vec3(0.9, 0.95, 1.0);
                    
                    float depth = smoothstep(0.0, 0.4, vUv.x);
                    vec3 waterColor = mix(shallowColor, deepColor, depth);
                    
                    // Foam on wave peaks
                    float foam = smoothstep(0.8, 1.5, vWaveHeight + 0.8);
                    waterColor = mix(waterColor, foamColor, foam * 0.5);
                    
                    // Shimmer effect
                    float shimmer = sin(vUv.x * 50.0 + time * 3.0) * sin(vUv.y * 50.0 + time * 2.5) * 0.05;
                    waterColor += shimmer;
                    
                    gl_FragColor = vec4(waterColor, 0.85);
                }
            `;
            
            oceanUniforms = { time: { value: 0 } };
            
            const oceanMat = new THREE.ShaderMaterial({
                uniforms: oceanUniforms,
                vertexShader: oceanVertexShader,
                fragmentShader: oceanFragmentShader,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            oceanMesh = new THREE.Mesh(oceanGeo, oceanMat);
            oceanMesh.rotation.x = -Math.PI / 2;
            oceanMesh.position.set(beachEdgeX + 280, 0.1, worldSize / 2);
            scene.add(oceanMesh);
            
            // Shore foam/tide line
            const shoreGeo = new THREE.PlaneGeometry(20, worldSize * 1.2);
            const shoreMat = new THREE.MeshLambertMaterial({
                color: 0x60e0e8,
                transparent: true,
                opacity: 0.6
            });
            const shore = new THREE.Mesh(shoreGeo, shoreMat);
            shore.rotation.x = -Math.PI / 2;
            shore.position.set(beachEdgeX + 5, 0.05, worldSize / 2);
            scene.add(shore);
        }
        
        // Update ocean waves
        function updateOcean() {
            if (oceanUniforms) {
                oceanUniforms.time.value = performance.now() / 1000;
            }
        }

        // --- WORLD GENERATION ---
        function generateCityGrid() {
            // Initialize Grid - beach is now 7 tiles wide (expanded)
            for(let x=0; x<CONFIG.gridSize; x++) {
                worldGrid[x] = [];
                for(let z=0; z<CONFIG.gridSize; z++) {
                    if (x > CONFIG.gridSize - 7) {
                        worldGrid[x][z] = 2; // Sand (expanded beach)
                    } else {
                        if (x % 2 !== 0 && z % 2 !== 0) {
                            worldGrid[x][z] = 1; // Building
                        } else {
                            worldGrid[x][z] = 0; // Road
                            roadTiles.push({x: x, z: z});
                        }
                    }
                }
            }

            // OPTIMIZED Building creation - uses texture instead of individual meshes
            const BUILDING_COLORS = [
                0x8899aa, 0xaa8866, 0xe8e0d0, 0x607080, 
                0xd0c0a0, 0x556677, 0xf0e8d8, 0x8b7355
            ];
            
            // Shared geometries to reduce memory
            const sharedBuildingGeo = new THREE.BoxGeometry(1, 1, 1);
            
            function createVariedBuilding(px, pz, height) {
                const colorIdx = Math.floor(Math.random() * BUILDING_COLORS.length);
                const baseWidth = (CONFIG.tileSize - 4) * (0.9 + Math.random() * 0.2);
                const baseDepth = (CONFIG.tileSize - 4) * (0.9 + Math.random() * 0.2);
                
                // Single mesh building with texture
                const buildingMat = new THREE.MeshLambertMaterial({ 
                map: textures.building, 
                    color: BUILDING_COLORS[colorIdx]
                });
                buildingMat.map = textures.building.clone();
                buildingMat.map.repeat.set(1, Math.floor(height / 8));
                buildingMat.map.needsUpdate = true;
                
                const building = new THREE.Mesh(sharedBuildingGeo, buildingMat);
                building.scale.set(baseWidth, height, baseDepth);
                building.position.set(px, height / 2, pz);
                building.castShadow = true;
                building.receiveShadow = true;
                
                return { group: building, width: baseWidth, depth: baseDepth };
            }
            
            const geoRoad = new THREE.PlaneGeometry(CONFIG.tileSize, CONFIG.tileSize);
            const matRoad = new THREE.MeshStandardMaterial({ 
                map: textures.road, 
                roughness: 0.9,
                metalness: 0.1
            });
            
            const matSand = new THREE.MeshStandardMaterial({ 
                map: textures.sand, 
                roughness: 1.0 
            });

            // Instantiate
            for(let x=0; x<CONFIG.gridSize; x++) {
                for(let z=0; z<CONFIG.gridSize; z++) {
                    const type = worldGrid[x][z];
                    const px = x * CONFIG.tileSize;
                    const pz = z * CONFIG.tileSize;

                    if (type === 1) {
                        const h = THREE.MathUtils.randFloat(CONFIG.buildingHeightMin, CONFIG.buildingHeightMax);
                        const building = createVariedBuilding(px, pz, h);
                        scene.add(building.group);
                        
                        buildings.push({ 
                            minX: px - building.width/2, maxX: px + building.width/2,
                            minZ: pz - building.depth/2, maxZ: pz + building.depth/2,
                            mesh: building.group
                        });

                        // Sidewalk
                        const sw = new THREE.Mesh(
                            new THREE.BoxGeometry(CONFIG.tileSize, 1, CONFIG.tileSize), 
                            new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 })
                        );
                        sw.position.set(px, 0.5, pz);
                        sw.receiveShadow = true;
                        scene.add(sw);

                    } else if (type === 0) {
                        const mesh = new THREE.Mesh(geoRoad, matRoad);
                        mesh.rotation.x = -Math.PI/2;
                        mesh.position.set(px, 0.05, pz);
                        mesh.receiveShadow = true;
                        
                        if (x % 2 === 0 && z % 2 !== 0) {
                            mesh.rotation.z = Math.PI/2;
                        }

                        scene.add(mesh);

                    } else if (type === 2) {
                        const mesh = new THREE.Mesh(geoRoad, matSand);
                        mesh.rotation.x = -Math.PI/2;
                        mesh.position.set(px, 0.05, pz);
                        mesh.receiveShadow = true;
                        scene.add(mesh);

                        // Only place palm trees outside of theme park area
                        if (Math.random() > 0.8) {
                            // Check if this position is NOT in the theme park area
                            const parkBounds = getThemeParkBoundsForTrees();
                            if (!parkBounds || px < parkBounds.minX - 5 || px > parkBounds.maxX + 5 || 
                                pz < parkBounds.minZ - 5 || pz > parkBounds.maxZ + 5) {
                                createPalmTree(px, pz);
                            }
                        }
                    }
                }
            }

            // Add traffic lights at major intersections only - NOT on beach (beach starts at gridSize-7)
            const beachStartGrid = CONFIG.gridSize - 7;
            const majorIntersections = [
                {x: 4, z: 4}, {x: 8, z: 8}, {x: 12, z: 12}, 
                {x: 4, z: 12}, {x: 12, z: 4}
            ];
            
            majorIntersections.forEach(intersection => {
                // Only place if within city bounds (not on beach)
                if (intersection.x < beachStartGrid && intersection.z < CONFIG.gridSize) {
                    createTrafficLight(intersection.x * CONFIG.tileSize, intersection.z * CONFIG.tileSize);
                }
            });

            // Realistic Ocean with multiple layers
            createOcean();
            
            spawnTraffic();
            spawnNPCs();
            createBeachProps();
            
            // Add theme park at the beach!
            createThemePark();
        }

        // --- REALISTIC VEHICLE CREATION ---
        function createCar(carType = null) {
            const types = Object.keys(CAR_TYPES);
            const typeKey = carType || types[Math.floor(Math.random() * types.length)];
            const type = CAR_TYPES[typeKey];
            
            const carGroup = new THREE.Group();
            const color = type.colors[Math.floor(Math.random() * type.colors.length)];
            
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.2,
                metalness: 0.8
            });
            
            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x1a2a3a,
                transparent: true,
                opacity: 0.8,
                roughness: 0.05,
                metalness: 0.9
            });
            
            const chromeMat = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.1,
                metalness: 1.0
            });
            
            const tireMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.9
            });
            
            const rimMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.9,
                roughness: 0.2
            });
            
            let length, width, height, wheelRadius, cabinOffset;
            
            if (typeKey === 'SPORTS') {
                length = 4.2; width = 1.9; height = 1.1; wheelRadius = 0.35; cabinOffset = 0.1;
                
                // Low sleek body
                const bodyShape = new THREE.Shape();
                bodyShape.moveTo(-length/2, 0);
                bodyShape.lineTo(-length/2, height * 0.4);
                bodyShape.lineTo(-length/4, height * 0.7);
                bodyShape.lineTo(length/4, height * 0.7);
                bodyShape.lineTo(length/2, height * 0.3);
                bodyShape.lineTo(length/2, 0);
                bodyShape.lineTo(-length/2, 0);
                
                const extrudeSettings = { steps: 1, depth: width, bevelEnabled: false };
                const bodyGeo = new THREE.ExtrudeGeometry(bodyShape, extrudeSettings);
                bodyGeo.center();
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.y = Math.PI / 2;
                body.position.y = height * 0.5;
                body.castShadow = true;
                carGroup.add(body);
                
                // Windshield
                const windshieldGeo = new THREE.PlaneGeometry(width * 0.85, height * 0.4);
                const windshield = new THREE.Mesh(windshieldGeo, windowMat);
                windshield.position.set(0, height * 0.75, length * 0.1);
                windshield.rotation.x = -Math.PI * 0.35;
                carGroup.add(windshield);
                
                // Rear window
                const rearGeo = new THREE.PlaneGeometry(width * 0.8, height * 0.35);
                const rearWindow = new THREE.Mesh(rearGeo, windowMat);
                rearWindow.position.set(0, height * 0.7, -length * 0.2);
                rearWindow.rotation.x = Math.PI * 0.25;
                carGroup.add(rearWindow);
                
            } else if (typeKey === 'MUSCLE') {
                length = 4.8; width = 2.0; height = 1.3; wheelRadius = 0.38; cabinOffset = 0.15;
                
                // Boxy muscle car body
                const bodyGeo = new THREE.BoxGeometry(width, height * 0.5, length);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = height * 0.4;
                body.castShadow = true;
                carGroup.add(body);
                
                // Hood bulge
                const hoodGeo = new THREE.BoxGeometry(width * 0.3, 0.15, length * 0.25);
                const hood = new THREE.Mesh(hoodGeo, bodyMat);
                hood.position.set(0, height * 0.7, length * 0.28);
                carGroup.add(hood);
                
                // Cabin
                const cabinGeo = new THREE.BoxGeometry(width * 0.9, height * 0.4, length * 0.4);
                const cabin = new THREE.Mesh(cabinGeo, bodyMat);
                cabin.position.set(0, height * 0.85, -length * 0.05);
                cabin.castShadow = true;
                carGroup.add(cabin);
                
                // Windows
                const windshieldGeo = new THREE.PlaneGeometry(width * 0.8, height * 0.35);
                const windshield = new THREE.Mesh(windshieldGeo, windowMat);
                windshield.position.set(0, height * 0.9, length * 0.12);
                windshield.rotation.x = -Math.PI * 0.25;
                carGroup.add(windshield);
                
            } else if (typeKey === 'SUV') {
                length = 4.6; width = 2.1; height = 1.9; wheelRadius = 0.42; cabinOffset = 0.2;
                
                // Tall boxy body
                const bodyGeo = new THREE.BoxGeometry(width, height * 0.6, length);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = height * 0.45;
                body.castShadow = true;
                carGroup.add(body);
                
                // Upper cabin
                const cabinGeo = new THREE.BoxGeometry(width * 0.95, height * 0.45, length * 0.65);
                const cabin = new THREE.Mesh(cabinGeo, bodyMat);
                cabin.position.set(0, height * 0.95, -length * 0.08);
                cabin.castShadow = true;
                carGroup.add(cabin);
                
                // Windows all around
                const windshieldGeo = new THREE.PlaneGeometry(width * 0.85, height * 0.35);
                const windshield = new THREE.Mesh(windshieldGeo, windowMat);
                windshield.position.set(0, height * 0.95, length * 0.2);
                windshield.rotation.x = -Math.PI * 0.15;
                carGroup.add(windshield);
                
                // Side windows
                const sideWinGeo = new THREE.PlaneGeometry(length * 0.5, height * 0.3);
                const leftWin = new THREE.Mesh(sideWinGeo, windowMat);
                leftWin.position.set(-width * 0.48, height * 0.95, -length * 0.08);
                leftWin.rotation.y = Math.PI / 2;
                carGroup.add(leftWin);
                const rightWin = leftWin.clone();
                rightWin.position.x = width * 0.48;
                carGroup.add(rightWin);
                
            } else if (typeKey === 'COUPE') {
                length = 4.0; width = 1.85; height = 1.25; wheelRadius = 0.34; cabinOffset = 0.1;
                
                // Sporty coupe body
                const bodyGeo = new THREE.BoxGeometry(width, height * 0.5, length);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = height * 0.4;
                body.castShadow = true;
                carGroup.add(body);
                
                // Sloping roof
                const roofGeo = new THREE.BoxGeometry(width * 0.88, height * 0.35, length * 0.45);
                const roof = new THREE.Mesh(roofGeo, bodyMat);
                roof.position.set(0, height * 0.8, -length * 0.05);
                roof.castShadow = true;
                carGroup.add(roof);
                
                // Windshield
                const windshieldGeo = new THREE.PlaneGeometry(width * 0.8, height * 0.38);
                const windshield = new THREE.Mesh(windshieldGeo, windowMat);
                windshield.position.set(0, height * 0.85, length * 0.15);
                windshield.rotation.x = -Math.PI * 0.28;
                carGroup.add(windshield);
                
            } else { // SEDAN
                length = 4.4; width = 1.85; height = 1.4; wheelRadius = 0.35; cabinOffset = 0.15;
                
                // Standard sedan body
                const bodyGeo = new THREE.BoxGeometry(width, height * 0.45, length);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = height * 0.38;
                body.castShadow = true;
                carGroup.add(body);
                
                // Cabin/greenhouse
                const cabinGeo = new THREE.BoxGeometry(width * 0.9, height * 0.4, length * 0.5);
                const cabin = new THREE.Mesh(cabinGeo, bodyMat);
                cabin.position.set(0, height * 0.78, -length * 0.02);
                cabin.castShadow = true;
                carGroup.add(cabin);
                
                // Windshield
                const windshieldGeo = new THREE.PlaneGeometry(width * 0.82, height * 0.35);
                const windshield = new THREE.Mesh(windshieldGeo, windowMat);
                windshield.position.set(0, height * 0.82, length * 0.2);
                windshield.rotation.x = -Math.PI * 0.22;
                carGroup.add(windshield);
                
                // Rear window
                const rearGeo = new THREE.PlaneGeometry(width * 0.78, height * 0.3);
                const rearWindow = new THREE.Mesh(rearGeo, windowMat);
                rearWindow.position.set(0, height * 0.8, -length * 0.25);
                rearWindow.rotation.x = Math.PI * 0.2;
                carGroup.add(rearWindow);
            }
            
            // WHEELS for all car types
            const wheelGeo = new THREE.CylinderGeometry(wheelRadius, wheelRadius, 0.25, 16);
            wheelGeo.rotateZ(Math.PI / 2);
            
            const rimGeo = new THREE.CylinderGeometry(wheelRadius * 0.6, wheelRadius * 0.6, 0.26, 8);
            rimGeo.rotateZ(Math.PI / 2);
            
            const wheelPositions = [
                { x: -width/2 + 0.1, z: length * 0.32 },
                { x: width/2 - 0.1, z: length * 0.32 },
                { x: -width/2 + 0.1, z: -length * 0.32 },
                { x: width/2 - 0.1, z: -length * 0.32 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, tireMat);
                wheel.position.set(pos.x, wheelRadius, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
                
                const rim = new THREE.Mesh(rimGeo, rimMat);
                rim.position.copy(wheel.position);
                carGroup.add(rim);
            });
            
            // HEADLIGHTS
            const headlightGeo = new THREE.BoxGeometry(0.2, 0.12, 0.08);
            const headlightMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
            
            const hl1 = new THREE.Mesh(headlightGeo, headlightMat);
            hl1.position.set(width * 0.35, height * 0.35, length/2 - 0.02);
            carGroup.add(hl1);
            const hl2 = hl1.clone();
            hl2.position.x = -width * 0.35;
            carGroup.add(hl2);
            
            // TAILLIGHTS
            const taillightGeo = new THREE.BoxGeometry(0.25, 0.1, 0.06);
            const taillightMat = new THREE.MeshBasicMaterial({ color: 0xcc0000 });
            
            const tl1 = new THREE.Mesh(taillightGeo, taillightMat);
            tl1.position.set(width * 0.35, height * 0.35, -length/2 + 0.02);
            carGroup.add(tl1);
            const tl2 = tl1.clone();
            tl2.position.x = -width * 0.35;
            carGroup.add(tl2);
            
            // Chrome bumpers
            const frontBumper = new THREE.Mesh(
                new THREE.BoxGeometry(width * 0.95, 0.15, 0.12),
                chromeMat
            );
            frontBumper.position.set(0, height * 0.18, length/2);
            carGroup.add(frontBumper);
            
            const rearBumper = frontBumper.clone();
            rearBumper.position.z = -length/2;
            carGroup.add(rearBumper);
            
            const carObj = {
                mesh: carGroup,
                type: typeKey,
                name: type.name,
                speed: 0,
                maxSpeed: type.speed,
                acceleration: type.acceleration,
                handling: type.handling,
                rotation: 0,
                velocity: new THREE.Vector3(0, 0, 0),
                isPlayerControlled: false,
                dimensions: {
                    width: width,
                    height: height,
                    length: length
                },
                entered: false,
                aiState: 'driving',
                aiTimer: 0,
                targetSpeed: type.speed * 0.6,
                wheelRadius: wheelRadius
            };

            carGroup.userData = { parentCar: carObj };
            return carObj;
        }

        function spawnTraffic() {
            // Filter road tiles to exclude beach area
            const cityRoads = roadTiles.filter(tile => tile.x < CONFIG.gridSize - 8);
            
            for(let i = 0; i < CONFIG.maxCars; i++) {
                const tile = cityRoads[Math.floor(Math.random() * cityRoads.length)];
                const car = createCar();
                
                car.mesh.position.set(
                    tile.x * CONFIG.tileSize + (Math.random() - 0.5) * 5,
                    car.wheelRadius || 0.35, // Position based on wheel radius
                    tile.z * CONFIG.tileSize + (Math.random() - 0.5) * 5
                );
                
                // Set initial direction based on road
                const initialRotation = Math.floor(Math.random() * 4) * (Math.PI / 2);
                car.mesh.rotation.y = initialRotation;
                car.rotation = initialRotation;
                
                car.mesh.castShadow = true;
                scene.add(car.mesh);
                
                cars.push(car);
            }
        }

        // --- FIXED VEHICLE ENTRY SYSTEM ---
        function checkNearbyVehicles() {
            if (isInVehicle || isHotwiring || isInteractingWithNPC) return null;
            
            let nearestCar = null;
            let nearestDistance = Infinity;
            
            cars.forEach(car => {
                if (car.isPlayerControlled) return;
                
                const distance = playerGroup.position.distanceTo(car.mesh.position);
                if (distance < CONFIG.enterDistance && distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestCar = car;
                }
            });
            
            return nearestCar;
        }

        function startHotwiring(car) {
            if (isHotwiring || isInVehicle) return;
            
            isHotwiring = true;
            hotwireStartTime = Date.now();
            currentVehicle = car;
            
            document.getElementById('hotwire-ui').style.display = 'block';
            
            // Update hotwire progress
            function updateHotwire() {
                if (!isHotwiring) return;
                
                const elapsed = Date.now() - hotwireStartTime;
                const progress = Math.min(100, (elapsed / CONFIG.hotwireTime) * 100);
                
                document.getElementById('hotwire-progress-fill').style.width = progress + '%';
                
                if (progress >= 100) {
                    // Hotwire complete
                    isHotwiring = false;
                    document.getElementById('hotwire-ui').style.display = 'none';
                    enterVehicle(currentVehicle);
                } else if (keys.e) {
                    // Continue hotwiring
                    requestAnimationFrame(updateHotwire);
                } else {
                    // Hotwire cancelled
                    isHotwiring = false;
                    document.getElementById('hotwire-ui').style.display = 'none';
                    currentVehicle = null;
                }
            }
            
            updateHotwire();
        }

        function enterVehicle(car) {
            if (isInVehicle) return;
            
            isInVehicle = true;
            currentVehicle = car;
            car.isPlayerControlled = true;
            car.entered = true;
            car.speed = 0;
            
            // Hide player
            playerGroup.visible = false;
            
            // Position camera
            cameraMode = 'vehicle';
            
            // Update HUD
            document.getElementById('vehicle-hud').style.display = 'block';
            document.getElementById('vehicle-name').textContent = car.name;
            document.getElementById('crosshair').style.display = 'none';
            
            // Hide prompt
            document.getElementById('enter-prompt').style.display = 'none';
        }

        function exitVehicle() {
            if (!isInVehicle || !currentVehicle) return;
            
            // Position player next to vehicle on the driver's side
            const offset = new THREE.Vector3(-currentVehicle.dimensions.width - 0.5, 0, 0);
            offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), currentVehicle.mesh.rotation.y);
            playerGroup.position.copy(currentVehicle.mesh.position).add(offset);
            playerGroup.position.y = 0;
            
            // Show player and all parts
            playerGroup.visible = true;
            playerGroup.traverse((child) => {
                if (child.isMesh) {
                    child.visible = true;
                }
            });
            
            // Update vehicle state
            currentVehicle.isPlayerControlled = false;
            currentVehicle.speed = 0;
            currentVehicle.velocity.set(0, 0, 0);
            
            // Reset state
            isInVehicle = false;
            currentVehicle = null;
            
            // Update HUD
            document.getElementById('vehicle-hud').style.display = 'none';
            
            // Switch back to third person
            cameraMode = 'third';
            updateWeaponVisuals(); // Update crosshair visibility
        }

        // --- TRAFFIC LIGHT SYSTEM ---
        function createTrafficLight(x, z) {
            const h = 7;
            // Position pole on the corner/sidewalk, not in the road
            const offsetX = CONFIG.tileSize / 2 - 1;
            const offsetZ = CONFIG.tileSize / 2 - 1;
            
            const poleGroup = new THREE.Group();
            
            // Main pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.12, 0.15, h), 
                new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.3})
            );
            pole.position.y = h/2;
            pole.castShadow = true;
            poleGroup.add(pole);
            
            // Horizontal arm extending over the road
            const arm = new THREE.Mesh(
                new THREE.BoxGeometry(6, 0.15, 0.15),
                new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.3})
            );
            arm.position.set(-2.5, h - 0.5, 0);
            poleGroup.add(arm);

            // Traffic light box hanging from arm
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 2.5, 0.6), 
                new THREE.MeshStandardMaterial({color: 0x222222, metalness: 0.5})
            );
            box.position.set(-5, h - 2, 0);
            poleGroup.add(box);

            const red = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshBasicMaterial({color: 0x330000}));
            red.position.set(0, 0.8, 0.35);
            box.add(red);
            
            const yellow = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshBasicMaterial({color: 0x333300}));
            yellow.position.set(0, 0, 0.35);
            box.add(yellow);
            
            const green = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            green.position.set(0, -0.8, 0.35);
            box.add(green);
            
            // Position on corner of intersection
            poleGroup.position.set(x + offsetX, 0, z + offsetZ);
            scene.add(poleGroup);
            
            // Realistic traffic light timing
            trafficLights.push({
                mesh: box, 
                lights: {red, yellow, green},
                state: 'green',
                timer: 15,
                pos: new THREE.Vector3(x, 0, z)
            });
        }

        function updateTrafficLights(deltaTime) {
            trafficLights.forEach(tl => {
                tl.timer -= deltaTime;
                
                if (tl.timer <= 0) {
                    // Change state
                    if (tl.state === 'green') {
                        tl.state = 'yellow';
                        tl.timer = 3; // Yellow for 3 seconds
                        tl.lights.green.material.color.setHex(0x003300);
                        tl.lights.yellow.material.color.setHex(0xffff00);
                    } else if (tl.state === 'yellow') {
                        tl.state = 'red';
                        tl.timer = 15; // Red for 15 seconds
                        tl.lights.yellow.material.color.setHex(0x333300);
                        tl.lights.red.material.color.setHex(0xff0000);
                    } else if (tl.state === 'red') {
                        tl.state = 'green';
                        tl.timer = 15; // Green for 15 seconds
                        tl.lights.red.material.color.setHex(0x330000);
                        tl.lights.green.material.color.setHex(0x00ff00);
                    }
                }
            });
        }

        // --- IMPROVED CAR AI ---
        function updateCarAI(car, deltaTime) {
            if (car.isPlayerControlled) return;
            
            // Update AI timer
            car.aiTimer += deltaTime;
            
            // STRICT BEACH BOUNDARY - NPC cars cannot drive on beach AT ALL
            const beachBoundaryX = (CONFIG.gridSize - 7) * CONFIG.tileSize;
            const currentGridX = Math.floor(car.mesh.position.x / CONFIG.tileSize);
            
            // If car somehow got on beach, teleport it back to a road
            if (currentGridX >= CONFIG.gridSize - 7 || car.mesh.position.x > beachBoundaryX - 10) {
                // Force immediate turn around
                car.rotation += Math.PI;
                car.mesh.rotation.y = car.rotation;
                car.speed = 0;
                car.targetSpeed = car.maxSpeed * 0.5;
                car.aiState = 'driving';
                
                // Move car back towards city
                car.mesh.position.x = Math.min(car.mesh.position.x, beachBoundaryX - 20);
                return;
            }
            
            // BEACH AVOIDANCE - Look ahead for sand
            const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
            
            // Look ahead to detect sand early
            const lookAheadDist = 25;
            const lookAheadPos = car.mesh.position.clone().add(forward.clone().multiplyScalar(lookAheadDist));
            
            const gridX = Math.floor(lookAheadPos.x / CONFIG.tileSize);
            const gridZ = Math.floor(lookAheadPos.z / CONFIG.tileSize);
            
            // Check if heading towards beach
            let headingToBeach = false;
            if (gridX >= CONFIG.gridSize - 8 || lookAheadPos.x > beachBoundaryX - 15) {
                headingToBeach = true;
            }
            if (gridX >= 0 && gridX < CONFIG.gridSize && gridZ >= 0 && gridZ < CONFIG.gridSize) {
                if (worldGrid[gridX] && worldGrid[gridX][gridZ] === 2) {
                    headingToBeach = true;
                }
            }

            let shouldStop = false;
            let stopDistance = 20;
            
            if (headingToBeach) {
                // Hard U-turn - do NOT go to beach
                if (Math.abs(car.speed) > 0.05) {
                    car.speed = THREE.MathUtils.lerp(car.speed, 0, 0.3);
                    car.targetSpeed = 0;
                    car.aiState = 'stopped';
                } else {
                    // Turn 90 or 180 degrees away from beach
                    car.rotation += (Math.random() > 0.5 ? Math.PI : Math.PI / 2);
                    car.mesh.rotation.y = car.rotation;
                    car.targetSpeed = car.maxSpeed * 0.5;
                    car.aiState = 'accelerating';
                    return; 
                }
            }

            // Check traffic lights - stop BEFORE the intersection, not at the light pole
            trafficLights.forEach(tl => {
                // Traffic light controls the intersection at tl.pos
                // Car should stop a bit before reaching the intersection center
                const intersectionCenter = tl.pos.clone();
                const toIntersection = new THREE.Vector3().subVectors(intersectionCenter, car.mesh.position);
                
                // Only check lights that are ahead of the car
                if (toIntersection.dot(forward) > 0) {
                    const distance = car.mesh.position.distanceTo(intersectionCenter);
                    // Stop 8-15 units before the intersection when light is not green
                    if (distance < stopDistance && distance > 5 && tl.state !== 'green') {
                        shouldStop = true;
                        const brakingDistance = Math.max(8, car.speed * 15);
                        if (distance < brakingDistance) {
                            car.targetSpeed = 0;
                            car.aiState = 'stopping';
                        }
                    }
                }
            });
            
            // AI behavior states
            switch(car.aiState) {
                case 'driving':
                    if (shouldStop) {
                        car.aiState = 'stopping';
                        car.targetSpeed = 0;
                    } else {
                        car.targetSpeed = car.maxSpeed * 0.6;
                        if (car.aiTimer > 5) {
                            car.aiTimer = 0;
                            if (Math.random() < 0.2) {
                                const tileX = Math.floor(car.mesh.position.x / CONFIG.tileSize);
                                const tileZ = Math.floor(car.mesh.position.z / CONFIG.tileSize);
                                const localX = car.mesh.position.x % CONFIG.tileSize;
                                const localZ = car.mesh.position.z % CONFIG.tileSize;
                                if (Math.abs(localX - CONFIG.tileSize/2) < 2 && Math.abs(localZ - CONFIG.tileSize/2) < 2) {
                                    car.rotation += (Math.random() > 0.5 ? 1 : -1) * Math.PI/2;
                                }
                            }
                        }
                    }
                    break;
                case 'stopping':
                    car.targetSpeed = 0;
                    if (car.speed < 0.01) {
                        car.aiState = 'stopped';
                        car.aiTimer = 0;
                    }
                    break;
                case 'stopped':
                    if (!shouldStop) {
                        car.aiState = 'accelerating';
                        car.aiTimer = 0;
                    }
                    break;
                case 'accelerating':
                    car.targetSpeed = car.maxSpeed * 0.6;
                    if (Math.abs(car.speed - car.targetSpeed) < 0.01) {
                        car.aiState = 'driving';
                    }
                    break;
            }
            
            car.speed = THREE.MathUtils.lerp(car.speed, car.targetSpeed, 0.05);
            car.mesh.position.add(forward.multiplyScalar(car.speed));
            
            // 4. COLLISION: Car vs NPC
            npcs.forEach(npc => {
                if (npc.mesh.position.distanceTo(car.mesh.position) < 4) {
                    car.speed = 0; 
                }
            });

            car.mesh.rotation.y = car.rotation;
            
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            if (car.mesh.position.x < 0) car.mesh.position.x = worldSize - 5;
            if (car.mesh.position.x > worldSize) car.mesh.position.x = 5;
            if (car.mesh.position.z < 0) car.mesh.position.z = worldSize - 5;
            if (car.mesh.position.z > worldSize) car.mesh.position.z = 5;
        }

        // 4 & 5. NEW REALISTIC PLAYER MODEL
        function createPlayer() {
            playerGroup = new THREE.Group();

            const skinColor = 0xdcb490;
            const shirtColor = 0x00aaff;
            const pantsColor = 0x333333;

            const skinMat = new THREE.MeshStandardMaterial({ color: skinColor });
            const shirtMat = new THREE.MeshStandardMaterial({ color: shirtColor });
            const pantsMat = new THREE.MeshStandardMaterial({ color: pantsColor });

            // Torso (Rectangular)
            const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.25);
            const torso = new THREE.Mesh(torsoGeo, shirtMat);
            torso.position.y = 1.15; // Legs (0.8) + Half Torso (0.35)
            torso.castShadow = true;
            playerGroup.add(torso);

            // Head
            const headGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            playerHead = new THREE.Mesh(headGeo, skinMat);
            playerHead.position.y = 0.5;
            torso.add(playerHead);

            playerTorso = torso;

            // Legs (Groups for animation)
            const legGeo = new THREE.BoxGeometry(0.18, 0.8, 0.2);
            
            playerLeftLeg = new THREE.Group();
            playerLeftLeg.position.set(-0.13, -0.35, 0);
            torso.add(playerLeftLeg);
            const leftLegMesh = new THREE.Mesh(legGeo, pantsMat);
            leftLegMesh.position.y = -0.4;
            leftLegMesh.castShadow = true;
            playerLeftLeg.add(leftLegMesh);

            playerRightLeg = new THREE.Group();
            playerRightLeg.position.set(0.13, -0.35, 0);
            torso.add(playerRightLeg);
            const rightLegMesh = new THREE.Mesh(legGeo, pantsMat);
            rightLegMesh.position.y = -0.4;
            rightLegMesh.castShadow = true;
            playerRightLeg.add(rightLegMesh);

            // Right Arm (for weapon holding)
            playerArm = new THREE.Group();
            playerArm.position.set(0.35, 0.2, 0);
            torso.add(playerArm);

            const armGeo = new THREE.BoxGeometry(0.15, 0.7, 0.15);
            const arm = new THREE.Mesh(armGeo, skinMat);
            arm.position.y = -0.3;
            arm.castShadow = true;
            playerArm.add(arm);
            
            // Left Arm (for animation)
            playerLeftArm = new THREE.Group();
            playerLeftArm.position.set(-0.35, 0.2, 0);
            torso.add(playerLeftArm);
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.y = -0.3;
            leftArm.castShadow = true;
            playerLeftArm.add(leftArm);

            // Weapon holder
            playerGun = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.4), new THREE.MeshStandardMaterial({color: 0x333333}));
            playerGun.position.set(0, -0.6, 0.1);
            playerGun.visible = false;
            playerArm.add(playerGun);

            scene.add(playerGroup);
            
            // Spawn on beach - south of theme park, nice open area
            const beachX = (CONFIG.gridSize - 4) * CONFIG.tileSize;
            const beachZ = (CONFIG.gridSize * 0.5) * CONFIG.tileSize; // Middle of beach, away from theme park
            playerGroup.position.set(beachX, 0, beachZ);
        }
        
        // Animation system for player
        function updatePlayerAnimation(deltaTime, isMoving, isSprinting) {
            if (!playerLeftLeg || !playerRightLeg) return;
            
            const animSpeed = isSprinting ? 15 : (isMoving ? 10 : 0);
            const animAmplitude = isSprinting ? 0.8 : (isMoving ? 0.5 : 0);
            
            if (isMoving) {
                playerAnimTime += deltaTime * animSpeed;
                
                // Leg swing
                playerLeftLeg.rotation.x = Math.sin(playerAnimTime) * animAmplitude;
                playerRightLeg.rotation.x = Math.sin(playerAnimTime + Math.PI) * animAmplitude;
                
                // Arm swing (opposite to legs)
                if (playerLeftArm) {
                    playerLeftArm.rotation.x = Math.sin(playerAnimTime + Math.PI) * animAmplitude * 0.6;
                }
                
                // Slight torso bob
                if (playerTorso) {
                    playerTorso.position.y = 1.15 + Math.abs(Math.sin(playerAnimTime * 2)) * 0.03;
                }
            } else {
                // Idle animation - gentle breathing
                playerAnimTime += deltaTime * 2;
                
                // Reset to neutral with slight idle movement
                playerLeftLeg.rotation.x = THREE.MathUtils.lerp(playerLeftLeg.rotation.x, 0, 0.1);
                playerRightLeg.rotation.x = THREE.MathUtils.lerp(playerRightLeg.rotation.x, 0, 0.1);
                
                if (playerLeftArm) {
                    playerLeftArm.rotation.x = THREE.MathUtils.lerp(playerLeftArm.rotation.x, 0, 0.1);
                }
                
                // Subtle breathing
                if (playerTorso) {
                    playerTorso.position.y = 1.15 + Math.sin(playerAnimTime) * 0.01;
                }
            }
        }

        // Helper function to get theme park bounds for excluding palm trees
        function getThemeParkBoundsForTrees() {
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            const beachStartX = (CONFIG.gridSize - 6) * CONFIG.tileSize;
            const parkCenterX = beachStartX + 60;
            const parkCenterZ = worldSize * 0.15;
            return {
                minX: parkCenterX - 60,
                maxX: parkCenterX + 60,
                minZ: parkCenterZ - 50,
                maxZ: parkCenterZ + 50
            };
        }
        
        // REALISTIC palm tree - balanced for performance
        const trunkMat = new THREE.MeshLambertMaterial({color: 0x8B4513});
        const leafMat = new THREE.MeshLambertMaterial({color: 0x228B22, side: THREE.DoubleSide});

        function createPalmTree(x, z) {
            const trunkH = 8 + Math.random() * 4;
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, trunkH, 6);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(x + (Math.random()-0.5)*10, trunkH/2, z + (Math.random()-0.5)*10);
            
            // Palm fronds - 6 leaves for balance
            const leaves = new THREE.Group();
            leaves.position.y = trunkH/2;
            const leafGeo = new THREE.PlaneGeometry(6, 2.5);
            
            for(let i = 0; i < 6; i++) {
                const leaf = new THREE.Mesh(leafGeo, leafMat);
                leaf.rotation.y = (i/6) * Math.PI * 2;
                leaf.rotation.x = -Math.PI/4;
                leaf.position.y = 0.5;
                leaves.add(leaf);
            }
            trunk.add(leaves);
            scene.add(trunk);
        }
        
        // Beach props - umbrellas, towels, lifeguard tower
        function createBeachProps() {
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            const beachStartX = (CONFIG.gridSize - 6) * CONFIG.tileSize;
            
            // Get theme park bounds to avoid placing beach props there
            const parkBounds = getThemeParkBoundsForTrees();
            
            // Helper function to check if position is in theme park area
            function isInThemePark(x, z) {
                return parkBounds && x >= parkBounds.minX - 10 && x <= parkBounds.maxX + 10 &&
                       z >= parkBounds.minZ - 10 && z <= parkBounds.maxZ + 10;
            }
            
            // Umbrella colors - bright beach colors
            const umbrellaColors = [0xff4444, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff, 0xff8800, 0x44ff44, 0xffffff];
            const towelColors = [0xff6666, 0x6666ff, 0xffff66, 0x66ff66, 0xff66ff, 0x66ffff, 0xffffff, 0xff9966];
            
            // Create beach umbrellas and towels - GRID-BASED PLACEMENT to avoid overlapping
            const sharedPoleGeo = new THREE.CylinderGeometry(0.12, 0.15, 5, 6);
            const sharedCanopyGeo = new THREE.ConeGeometry(3.5, 1.2, 6);
            const sharedTowelGeo = new THREE.PlaneGeometry(2.5, 4);
            const poleMat = new THREE.MeshLambertMaterial({ color: 0xdeb887 });
            
            // Use grid-based placement with spacing to prevent overlapping
            const spacingX = 18; // Horizontal spacing between umbrella groups
            const spacingZ = 25; // Vertical spacing between umbrella groups
            const numRows = Math.floor((worldSize - 100) / spacingZ);
            const numCols = 4; // Number of umbrellas across the beach width
            
            let umbrellaCount = 0;
            for (let row = 0; row < numRows && umbrellaCount < 14; row++) {
                for (let col = 0; col < numCols && umbrellaCount < 14; col++) {
                    // Add some randomness to grid positions (but not enough to overlap)
                    const baseX = beachStartX + 20 + col * spacingX;
                    const baseZ = 60 + row * spacingZ;
                    
                    // Add small random offset (within bounds to prevent overlap)
                    const x = baseX + (Math.random() - 0.5) * 6;
                    const z = baseZ + (Math.random() - 0.5) * 8;
                    
                    // Skip if in theme park area
                    if (isInThemePark(x, z)) continue;
                    
                    // 70% chance to place umbrella at each grid position
                    if (Math.random() > 0.3) {
                        const pole = new THREE.Mesh(sharedPoleGeo, poleMat);
                        pole.position.set(x, 2.5, z);
                        scene.add(pole);
                        
                        const canopyColor = umbrellaColors[Math.floor(Math.random() * umbrellaColors.length)];
                        const canopyMat = new THREE.MeshLambertMaterial({ color: canopyColor });
                        const canopy = new THREE.Mesh(sharedCanopyGeo, canopyMat);
                        canopy.position.y = 2.0;
                        pole.add(canopy);
                        
                        // Place towel next to umbrella with fixed offset (no overlap)
                        const towelColor = towelColors[Math.floor(Math.random() * towelColors.length)];
                        const towelMat = new THREE.MeshLambertMaterial({ color: towelColor, side: THREE.DoubleSide });
                        const towel = new THREE.Mesh(sharedTowelGeo, towelMat);
                        towel.rotation.x = -Math.PI / 2;
                        towel.rotation.z = Math.random() * 0.5 - 0.25; // Slight random rotation
                        // Place towel 4-5 units away from umbrella to avoid overlap
                        const towelAngle = Math.random() * Math.PI * 2;
                        const towelDist = 4 + Math.random();
                        towel.position.set(x + Math.cos(towelAngle) * towelDist, 0.08, z + Math.sin(towelAngle) * towelDist);
                        scene.add(towel);
                        
                        umbrellaCount++;
                    }
                }
            }
            
            // Create lifeguard towers - positioned at fixed locations away from theme park
            const towerPositions = [
                { x: beachStartX + 50, z: worldSize * 0.55 },
                { x: beachStartX + 50, z: worldSize * 0.80 }
            ];
            
            towerPositions.forEach(pos => {
                if (!isInThemePark(pos.x, pos.z)) {
                    createLifeguardTower(pos.x, pos.z);
                }
            });
            
            // Beach chairs - grid-based placement
            const chairSpacing = 20;
            let chairCount = 0;
            for (let row = 0; row < 4 && chairCount < 10; row++) {
                for (let col = 0; col < 3 && chairCount < 10; col++) {
                    const x = beachStartX + 30 + col * chairSpacing + (Math.random() - 0.5) * 8;
                    const z = 80 + row * chairSpacing * 1.5 + (Math.random() - 0.5) * 10;
                    
                    // Skip if in theme park area
                    if (isInThemePark(x, z)) continue;
                    
                    if (Math.random() > 0.4) {
                        createBeachChair(x, z);
                        chairCount++;
                    }
                }
            }
        }
        
        // OPTIMIZED Lifeguard tower - simplified
        function createLifeguardTower(x, z) {
            const towerGroup = new THREE.Group();
            const legMat = new THREE.MeshLambertMaterial({ color: 0xc4a574 });
            
            // Single base pillar (simplified from 4 legs)
            const baseGeo = new THREE.BoxGeometry(4, 8, 4);
            const base = new THREE.Mesh(baseGeo, legMat);
            base.position.y = 4;
            towerGroup.add(base);
            
            // Cabin
            const cabinColors = [0xff6b6b, 0x6bff6b, 0x6b6bff, 0xffff6b];
            const cabinMat = new THREE.MeshLambertMaterial({ 
                color: cabinColors[Math.floor(Math.random() * cabinColors.length)] 
            });
            const cabinGeo = new THREE.BoxGeometry(5, 4, 5);
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.y = 10;
            cabin.castShadow = true;
            towerGroup.add(cabin);
            
            // Simple roof
            const roofMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const roofGeo = new THREE.ConeGeometry(4, 2.5, 4);
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 13.5;
            roof.rotation.y = Math.PI / 4;
            towerGroup.add(roof);
            
            towerGroup.position.set(x, 0, z);
            scene.add(towerGroup);
        }
        
        // OPTIMIZED Beach chair - simplified
        function createBeachChair(x, z) {
            const fabricColors = [0x0066cc, 0xcc0000, 0x00cc00, 0xffaa00];
            const fabricMat = new THREE.MeshLambertMaterial({ 
                color: fabricColors[Math.floor(Math.random() * fabricColors.length)]
            });
            
            // Single mesh chair
            const seatGeo = new THREE.BoxGeometry(1.2, 0.1, 2.2);
            const seat = new THREE.Mesh(seatGeo, fabricMat);
            seat.position.set(x, 0.5, z);
            seat.rotation.x = -0.3;
            seat.rotation.y = Math.random() * Math.PI * 2;
            scene.add(seat);
        }

        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }
        
        // === THEME PARK ===
        let themeParkRides = [];
        
        // Store theme park bounds globally for collision and palm tree exclusion
        let themeParkBounds = null;
        let themeParkStairs = null; // Store stair data for collision/walking
        
        function createThemePark() {
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            const beachStartX = (CONFIG.gridSize - 6) * CONFIG.tileSize;
            
            // Theme park location - northern part of the beach
            const parkCenterX = beachStartX + 60;
            const parkCenterZ = worldSize * 0.15;
            const platformWidth = 120;
            const platformDepth = 100;
            const platformHeight = 2;
            
            // Store bounds for collision detection and palm tree exclusion
            themeParkBounds = {
                minX: parkCenterX - platformWidth/2,
                maxX: parkCenterX + platformWidth/2,
                minZ: parkCenterZ - platformDepth/2,
                maxZ: parkCenterZ + platformDepth/2,
                height: platformHeight
            };
            
            // Create boardwalk/platform for theme park - slightly raised walkable surface
            const platformGeo = new THREE.BoxGeometry(platformWidth, platformHeight, platformDepth);
            const platformMat = new THREE.MeshStandardMaterial({ 
                color: 0x8b7355, 
                roughness: 0.8 
            });
            const platform = new THREE.Mesh(platformGeo, platformMat);
            platform.position.set(parkCenterX, 0.5, parkCenterZ); // Low platform at ground level
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Add platform to buildings array for collision detection
            // This prevents walking THROUGH the platform from the sides
            buildings.push({
                minX: themeParkBounds.minX,
                maxX: themeParkBounds.maxX,
                minZ: themeParkBounds.minZ,
                maxZ: themeParkBounds.maxZ,
                mesh: platform,
                isThemeParkPlatform: true
            });
            
            // Add decorative railing around platform edges
            createPlatformRailings(parkCenterX, parkCenterZ, platformWidth, platformDepth);
            
            // Create stairs at the entrance side (west side of platform)
            createPlatformStairs(themeParkBounds.minX, parkCenterZ, 2.0);
            
            // Create Ferris Wheel
            createFerrisWheel(parkCenterX - 20, parkCenterZ - 20);
            
            // Create Carousel
            createCarousel(parkCenterX + 25, parkCenterZ);
            
            // Create Swing Ride
            createSwingRide(parkCenterX - 25, parkCenterZ + 25);
            
            // Create Roller Coaster entrance
            createRollerCoaster(parkCenterX + 15, parkCenterZ - 30);
            
            // Entrance arch with neon
            createParkEntrance(parkCenterX - 50, parkCenterZ);
            
            // Ticket booth
            createTicketBooth(parkCenterX - 45, parkCenterZ + 15);
            
            // Food stands
            createFoodStand(parkCenterX + 35, parkCenterZ + 20, 'COTTON CANDY');
            createFoodStand(parkCenterX + 35, parkCenterZ - 15, 'HOT DOGS');
        }
        
        function createPlatformStairs(platformX, platformZ, platformTopY) {
            const stairsGroup = new THREE.Group();
            
            // Wooden stair material - visible brown color
            const stairMat = new THREE.MeshStandardMaterial({ 
                color: 0xcd853f, // Peru brown - nice visible wood color
                roughness: 0.8 
            });
            
            const numSteps = 5;
            const stepWidth = 10; // Width of stairs (Z direction)
            const stepDepth = 1.8; // Depth of each step (X direction)
            const stepHeight = platformTopY / numSteps; // Height of each step
            const totalStairLength = stepDepth * numSteps;
            
            // Store stair data globally for collision detection
            themeParkStairs = {
                startX: platformX - totalStairLength, // Bottom of stairs (furthest from platform)
                endX: platformX, // Top of stairs (at platform edge)
                centerZ: platformZ,
                halfWidth: stepWidth / 2,
                bottomY: 0,
                topY: platformTopY,
                totalLength: totalStairLength
            };
            
            // Create steps - step 0 is at the BOTTOM (ground level, furthest from platform)
            // step numSteps-1 is at the TOP (platform level, closest to platform)
            for (let i = 0; i < numSteps; i++) {
                const stepGeo = new THREE.BoxGeometry(stepDepth, stepHeight, stepWidth);
                const step = new THREE.Mesh(stepGeo, stairMat);
                
                // Steps start far from platform (most negative X) at ground level
                // and rise up as they get closer to platform edge
                const stepX = platformX - totalStairLength + (i * stepDepth) + stepDepth/2;
                const stepY = (i * stepHeight) + stepHeight/2;
                
                step.position.set(stepX, stepY, platformZ);
                step.receiveShadow = true;
                step.castShadow = true;
                stairsGroup.add(step);
            }
            
            // Add railings on both sides
            const railMat = new THREE.MeshStandardMaterial({ 
                color: 0x888888, // Gray metal
                roughness: 0.4,
                metalness: 0.6
            });
            
            for (let side = -1; side <= 1; side += 2) {
                const sideZ = platformZ + side * (stepWidth / 2);
                
                // Vertical posts at bottom and top of stairs
                const postHeight = 1.2;
                const postGeo = new THREE.CylinderGeometry(0.08, 0.1, postHeight, 8);
                
                // Bottom post (at ground level, far from platform)
                const bottomPost = new THREE.Mesh(postGeo, railMat);
                bottomPost.position.set(
                    platformX - totalStairLength,
                    postHeight / 2,
                    sideZ
                );
                stairsGroup.add(bottomPost);
                
                // Top post (at platform level)
                const topPost = new THREE.Mesh(postGeo, railMat);
                topPost.position.set(
                    platformX - stepDepth/2,
                    platformTopY + postHeight / 2,
                    sideZ
                );
                stairsGroup.add(topPost);
                
                // Middle posts along the stairs
                for (let i = 1; i < numSteps; i++) {
                    const midPost = new THREE.Mesh(postGeo, railMat);
                    const postX = platformX - totalStairLength + (i * stepDepth);
                    const postY = (i * stepHeight) + postHeight / 2;
                    midPost.position.set(postX, postY, sideZ);
                    stairsGroup.add(midPost);
                }
                
                // Angled handrail
                const railLength = Math.sqrt(totalStairLength ** 2 + platformTopY ** 2);
                const railAngle = Math.atan2(platformTopY, totalStairLength);
                
                const handrailGeo = new THREE.BoxGeometry(railLength, 0.1, 0.1);
                const handrail = new THREE.Mesh(handrailGeo, railMat);
                handrail.rotation.z = railAngle;
                handrail.position.set(
                    platformX - totalStairLength / 2 - stepDepth/4,
                    platformTopY / 2 + postHeight - 0.1,
                    sideZ
                );
                stairsGroup.add(handrail);
            }
            
            scene.add(stairsGroup);
        }
        
        // Check if a position is on the stairs and return the appropriate Y height
        function getStairHeight(x, z) {
            if (!themeParkStairs) return 0;
            
            const stairs = themeParkStairs;
            
            // Check if within stair bounds (X and Z)
            if (x >= stairs.startX && x <= stairs.endX &&
                z >= stairs.centerZ - stairs.halfWidth && z <= stairs.centerZ + stairs.halfWidth) {
                
                // Calculate progress along stairs (0 = bottom, 1 = top)
                const progress = (x - stairs.startX) / stairs.totalLength;
                
                // Linear interpolation from bottom to top
                return stairs.bottomY + (stairs.topY - stairs.bottomY) * progress;
            }
            
            // Check if on the platform itself
            if (themeParkBounds && 
                x >= themeParkBounds.minX && x <= themeParkBounds.maxX &&
                z >= themeParkBounds.minZ && z <= themeParkBounds.maxZ) {
                return stairs.topY; // Platform height
            }
            
            return 0; // Ground level
        }
        
        // Check if a position is on stairs or platform (for collision override)
        function isOnStairsOrPlatform(x, z) {
            if (!themeParkStairs) return false;
            
            const stairs = themeParkStairs;
            
            // Check if on stairs
            if (x >= stairs.startX && x <= stairs.endX &&
                z >= stairs.centerZ - stairs.halfWidth && z <= stairs.centerZ + stairs.halfWidth) {
                return true;
            }
            
            // Check if on platform
            if (themeParkBounds && 
                x >= themeParkBounds.minX && x <= themeParkBounds.maxX &&
                z >= themeParkBounds.minZ && z <= themeParkBounds.maxZ) {
                return true;
            }
            
            return false;
        }
        
        function createPlatformRailings(centerX, centerZ, width, depth) {
            const railMat = new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.6 });
            const railingsGroup = new THREE.Group();
            
            const railHeight = 1.2;
            const postSpacing = 8;
            
            // Create railings on all 4 sides (with gap on west side for stairs)
            const sides = [
                { dir: 'north', startX: centerX - width/2, startZ: centerZ - depth/2, lengthX: width, lengthZ: 0 },
                { dir: 'south', startX: centerX - width/2, startZ: centerZ + depth/2, lengthX: width, lengthZ: 0 },
                { dir: 'east', startX: centerX + width/2, startZ: centerZ - depth/2, lengthX: 0, lengthZ: depth },
                { dir: 'west', startX: centerX - width/2, startZ: centerZ - depth/2, lengthX: 0, lengthZ: depth } // Has stairs gap
            ];
            
            sides.forEach(side => {
                const isWest = side.dir === 'west';
                const length = side.lengthX || side.lengthZ;
                const numPosts = Math.floor(length / postSpacing);
                
                for (let i = 0; i <= numPosts; i++) {
                    const t = i / numPosts;
                    const px = side.startX + (side.lengthX * t);
                    const pz = side.startZ + (side.lengthZ * t);
                    
                    // Skip posts near stairs opening (center of west side)
                    if (isWest && Math.abs(pz - centerZ) < 8) continue;
                    
                    // Vertical post
                    const postGeo = new THREE.CylinderGeometry(0.1, 0.12, railHeight, 6);
                    const post = new THREE.Mesh(postGeo, railMat);
                    post.position.set(px, 1.5 + railHeight/2, pz);
                    railingsGroup.add(post);
                }
                
                // Horizontal rail
                if (side.lengthX > 0) {
                    const railGeo = new THREE.BoxGeometry(length, 0.15, 0.1);
                    const rail = new THREE.Mesh(railGeo, railMat);
                    rail.position.set(side.startX + length/2, 1.5 + railHeight, side.startZ);
                    railingsGroup.add(rail);
                } else if (!isWest) {
                    const railGeo = new THREE.BoxGeometry(0.1, 0.15, length);
                    const rail = new THREE.Mesh(railGeo, railMat);
                    rail.position.set(side.startX, 1.5 + railHeight, side.startZ + length/2);
                    railingsGroup.add(rail);
                } else {
                    // West side with gap - two separate rails
                    const gapCenter = centerZ;
                    const gapSize = 16;
                    const rail1Length = (gapCenter - gapSize/2) - side.startZ;
                    const rail2Length = (side.startZ + length) - (gapCenter + gapSize/2);
                    
                    if (rail1Length > 0) {
                        const railGeo1 = new THREE.BoxGeometry(0.1, 0.15, rail1Length);
                        const rail1 = new THREE.Mesh(railGeo1, railMat);
                        rail1.position.set(side.startX, 1.5 + railHeight, side.startZ + rail1Length/2);
                        railingsGroup.add(rail1);
                    }
                    
                    if (rail2Length > 0) {
                        const railGeo2 = new THREE.BoxGeometry(0.1, 0.15, rail2Length);
                        const rail2 = new THREE.Mesh(railGeo2, railMat);
                        rail2.position.set(side.startX, 1.5 + railHeight, gapCenter + gapSize/2 + rail2Length/2);
                        railingsGroup.add(rail2);
                    }
                }
            });
            
            scene.add(railingsGroup);
        }
        
        function createFerrisWheel(x, z) {
            const wheelGroup = new THREE.Group();
            
            // Main support structure
            const supportMat = new THREE.MeshStandardMaterial({ color: 0x444466, metalness: 0.8 });
            
            // Two A-frame supports
            for (let side = -1; side <= 1; side += 2) {
                const legGeo = new THREE.CylinderGeometry(0.5, 0.8, 35, 8);
                const leg = new THREE.Mesh(legGeo, supportMat);
                leg.position.set(side * 8, 17.5, 0);
                leg.rotation.z = side * 0.15;
                wheelGroup.add(leg);
            }
            
            // Wheel rim - vertical circle facing forward (Z direction)
            const wheelRadius = 18;
            const rimGeo = new THREE.TorusGeometry(wheelRadius, 0.5, 16, 48);
            const rimMat = new THREE.MeshStandardMaterial({ 
                color: 0xff4488, 
                emissive: 0xff2266,
                emissiveIntensity: 0.3
            });
            const rim = new THREE.Mesh(rimGeo, rimMat);
            rim.position.y = 22;
            // Rotate around Z to make the torus axis horizontal (along X, same as the support legs)
            rim.rotation.z = Math.PI / 2;
            wheelGroup.add(rim);
            
            // Spokes with lights
            const numSpokes = 8;
            const spokeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 });
            
            for (let i = 0; i < numSpokes; i++) {
                const angle = (i / numSpokes) * Math.PI * 2;
                const spokeGeo = new THREE.CylinderGeometry(0.15, 0.15, wheelRadius * 2, 6);
                const spoke = new THREE.Mesh(spokeGeo, spokeMat);
                spoke.position.y = 22;
                spoke.rotation.z = angle;
                wheelGroup.add(spoke);
            }
            
            // Gondolas with lights
            const gondolaColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da, 0xfcbad3, 0xa8d8ea];
            const numGondolas = 16;
            
            for (let i = 0; i < numGondolas; i++) {
                const angle = (i / numGondolas) * Math.PI * 2;
                const gondolaGroup = new THREE.Group();
                
                // Gondola body
                const gondolaGeo = new THREE.BoxGeometry(2.5, 3, 2.5);
                const gondolaColor = gondolaColors[i % gondolaColors.length];
                const gondolaMat = new THREE.MeshStandardMaterial({ 
                    color: gondolaColor,
                    emissive: gondolaColor,
                    emissiveIntensity: 0.4
                });
                const gondola = new THREE.Mesh(gondolaGeo, gondolaMat);
                gondolaGroup.add(gondola);
                
                // LED strip on gondola
                const ledGeo = new THREE.BoxGeometry(2.6, 0.2, 2.6);
                const ledMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const led = new THREE.Mesh(ledGeo, ledMat);
                led.position.y = 1.6;
                gondolaGroup.add(led);
                
                gondolaGroup.position.set(
                    Math.cos(angle) * wheelRadius,
                    22 + Math.sin(angle) * wheelRadius,
                    0
                );
                
                wheelGroup.add(gondolaGroup);
                
                // Store for animation
                themeParkRides.push({
                    type: 'gondola',
                    mesh: gondolaGroup,
                    parent: wheelGroup,
                    angle: angle,
                    radius: wheelRadius,
                    centerY: 22
                });
            }
            
            // Center hub with light
            const hubGeo = new THREE.CylinderGeometry(2, 2, 3, 16);
            const hubMat = new THREE.MeshStandardMaterial({ 
                color: 0xffdd44,
                emissive: 0xffaa00,
                emissiveIntensity: 0.6
            });
            const hub = new THREE.Mesh(hubGeo, hubMat);
            hub.position.y = 22;
            hub.rotation.x = Math.PI / 2;
            wheelGroup.add(hub);
            
            wheelGroup.position.set(x, 0, z);
            scene.add(wheelGroup);
            
            // Add collision box for ferris wheel support structure
            buildings.push({
                minX: x - 12,
                maxX: x + 12,
                minZ: z - 5,
                maxZ: z + 5,
                mesh: wheelGroup,
                isRide: true
            });
            
            // Store for animation
            themeParkRides.push({
                type: 'ferrisWheel',
                mesh: wheelGroup,
                rotationSpeed: 0.002
            });
        }
        
        function createCarousel(x, z) {
            const carouselGroup = new THREE.Group();
            
            // Base platform
            const baseGeo = new THREE.CylinderGeometry(10, 11, 2, 24);
            const baseMat = new THREE.MeshStandardMaterial({ 
                color: 0xdd6699,
                emissive: 0xcc4488,
                emissiveIntensity: 0.2
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 1;
            carouselGroup.add(base);
            
            // Center pole
            const poleGeo = new THREE.CylinderGeometry(1, 1.2, 12, 16);
            const poleMat = new THREE.MeshStandardMaterial({ 
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.4
            });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 8;
            carouselGroup.add(pole);
            
            // Roof
            const roofGeo = new THREE.ConeGeometry(12, 5, 24);
            const roofMat = new THREE.MeshStandardMaterial({ 
                color: 0xff6b6b,
                emissive: 0xff4444,
                emissiveIntensity: 0.3
            });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 15;
            carouselGroup.add(roof);
            
            // Horses
            const horseColors = [0xffffff, 0xf0e68c, 0xdda0dd, 0x87ceeb, 0xffa07a];
            const numHorses = 10;
            
            for (let i = 0; i < numHorses; i++) {
                const angle = (i / numHorses) * Math.PI * 2;
                const horseGroup = new THREE.Group();
                
                // Simplified horse body
                const bodyGeo = new THREE.BoxGeometry(1.5, 2, 3);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: horseColors[i % horseColors.length]
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 4;
                horseGroup.add(body);
                
                // Horse head
                const headGeo = new THREE.BoxGeometry(0.8, 1.5, 1);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0, 5, 1.8);
                head.rotation.x = 0.3;
                horseGroup.add(head);
                
                // Pole
                const hPoleMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700,
                    emissive: 0xffa500,
                    emissiveIntensity: 0.3
                });
                const hPoleGeo = new THREE.CylinderGeometry(0.15, 0.15, 10, 8);
                const hPole = new THREE.Mesh(hPoleGeo, hPoleMat);
                hPole.position.y = 6;
                horseGroup.add(hPole);
                
                horseGroup.position.set(
                    Math.cos(angle) * 7,
                    0,
                    Math.sin(angle) * 7
                );
                horseGroup.rotation.y = -angle + Math.PI / 2;
                
                carouselGroup.add(horseGroup);
                
                // Store for up/down animation
                themeParkRides.push({
                    type: 'horse',
                    mesh: horseGroup,
                    baseY: 0,
                    phase: i * 0.5
                });
            }
            
            // LED lights around edge
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const lightGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({ 
                    color: i % 2 === 0 ? 0xff00ff : 0x00ffff
                });
                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.set(
                    Math.cos(angle) * 10.5,
                    2.2,
                    Math.sin(angle) * 10.5
                );
                carouselGroup.add(light);
            }
            
            carouselGroup.position.set(x, 0, z);
            scene.add(carouselGroup);
            
            // Add collision box for carousel (circular approximation with square)
            buildings.push({
                minX: x - 12,
                maxX: x + 12,
                minZ: z - 12,
                maxZ: z + 12,
                mesh: carouselGroup,
                isRide: true
            });
            
            themeParkRides.push({
                type: 'carousel',
                mesh: carouselGroup,
                rotationSpeed: 0.01
            });
        }
        
        function createSwingRide(x, z) {
            const swingGroup = new THREE.Group();
            
            // Central tower
            const towerGeo = new THREE.CylinderGeometry(2, 3, 20, 12);
            const towerMat = new THREE.MeshStandardMaterial({ 
                color: 0x6677aa,
                emissive: 0x4455aa,
                emissiveIntensity: 0.2
            });
            const tower = new THREE.Mesh(towerGeo, towerMat);
            tower.position.y = 10;
            swingGroup.add(tower);
            
            // Rotating top disc
            const discGeo = new THREE.CylinderGeometry(10, 10, 1, 24);
            const discMat = new THREE.MeshStandardMaterial({ 
                color: 0xffaa44,
                emissive: 0xff8800,
                emissiveIntensity: 0.3
            });
            const disc = new THREE.Mesh(discGeo, discMat);
            disc.position.y = 20;
            swingGroup.add(disc);
            
            // Swing seats hanging from chains
            const numSwings = 12;
            for (let i = 0; i < numSwings; i++) {
                const angle = (i / numSwings) * Math.PI * 2;
                const swingSeat = new THREE.Group();
                
                // Chain
                const chainGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 6);
                const chainMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9 });
                const chain = new THREE.Mesh(chainGeo, chainMat);
                chain.position.y = -3;
                swingSeat.add(chain);
                
                // Seat
                const seatGeo = new THREE.BoxGeometry(1.5, 0.5, 1.5);
                const seatColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3];
                const seatMat = new THREE.MeshStandardMaterial({ 
                    color: seatColors[i % seatColors.length],
                    emissive: seatColors[i % seatColors.length],
                    emissiveIntensity: 0.3
                });
                const seat = new THREE.Mesh(seatGeo, seatMat);
                seat.position.y = -6;
                swingSeat.add(seat);
                
                swingSeat.position.set(
                    Math.cos(angle) * 8,
                    20,
                    Math.sin(angle) * 8
                );
                swingGroup.add(swingSeat);
            }
            
            // LED ring on disc
            const ringGeo = new THREE.TorusGeometry(9.5, 0.3, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.y = 20.6;
            ring.rotation.x = Math.PI / 2;
            swingGroup.add(ring);
            
            swingGroup.position.set(x, 0, z);
            scene.add(swingGroup);
            
            // Add collision box for swing ride
            buildings.push({
                minX: x - 12,
                maxX: x + 12,
                minZ: z - 12,
                maxZ: z + 12,
                mesh: swingGroup,
                isRide: true
            });
            
            themeParkRides.push({
                type: 'swingRide',
                mesh: swingGroup,
                rotationSpeed: 0.015
            });
        }
        
        function createRollerCoaster(x, z) {
            const coasterGroup = new THREE.Group();
            
            // Entrance building
            const entranceGeo = new THREE.BoxGeometry(15, 10, 8);
            const entranceMat = new THREE.MeshStandardMaterial({ 
                color: 0x8844aa,
                emissive: 0x6622aa,
                emissiveIntensity: 0.2
            });
            const entrance = new THREE.Mesh(entranceGeo, entranceMat);
            entrance.position.y = 5;
            coasterGroup.add(entrance);
            
            // Neon sign on entrance
            const signGeo = new THREE.BoxGeometry(12, 2, 0.3);
            const signMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const sign = new THREE.Mesh(signGeo, signMat);
            sign.position.set(0, 9, 4.2);
            coasterGroup.add(sign);
            
            // Some track structure visible
            const trackMat = new THREE.MeshStandardMaterial({ color: 0xdd4444, metalness: 0.8 });
            
            // Loop frame
            const loopGeo = new THREE.TorusGeometry(12, 0.5, 8, 24, Math.PI);
            const loop = new THREE.Mesh(loopGeo, trackMat);
            loop.position.set(-15, 12, 0);
            loop.rotation.y = Math.PI / 2;
            coasterGroup.add(loop);
            
            // Support pillars for loop
            for (let i = -1; i <= 1; i += 2) {
                const pillarGeo = new THREE.CylinderGeometry(0.5, 0.7, 24, 8);
                const pillar = new THREE.Mesh(pillarGeo, trackMat);
                pillar.position.set(-15, 12, i * 12);
                coasterGroup.add(pillar);
            }
            
            // LED strips on entrance
            for (let i = 0; i < 4; i++) {
                const stripGeo = new THREE.BoxGeometry(0.3, 8, 0.3);
                const stripMat = new THREE.MeshBasicMaterial({ 
                    color: i % 2 === 0 ? 0xff0066 : 0x00ff66
                });
                const strip = new THREE.Mesh(stripGeo, stripMat);
                strip.position.set(-6 + i * 4, 5, 4.2);
                coasterGroup.add(strip);
            }
            
            coasterGroup.position.set(x, 0, z);
            scene.add(coasterGroup);
            
            // Add collision box for roller coaster entrance building
            buildings.push({
                minX: x - 20,
                maxX: x + 10,
                minZ: z - 15,
                maxZ: z + 15,
                mesh: coasterGroup,
                isRide: true
            });
        }
        
        function createParkEntrance(x, z) {
            const entranceGroup = new THREE.Group();
            
            // Arch pillars
            const pillarMat = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                emissive: 0xffaa00,
                emissiveIntensity: 0.3
            });
            
            for (let side = -1; side <= 1; side += 2) {
                const pillarGeo = new THREE.CylinderGeometry(1, 1.2, 15, 12);
                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                pillar.position.set(0, 7.5, side * 10);
                entranceGroup.add(pillar);
            }
            
            // Arch top
            const archGeo = new THREE.TorusGeometry(10, 1, 8, 16, Math.PI);
            const archMat = new THREE.MeshStandardMaterial({ 
                color: 0xff4488,
                emissive: 0xff2266,
                emissiveIntensity: 0.4
            });
            const arch = new THREE.Mesh(archGeo, archMat);
            arch.position.set(0, 15, 0);
            arch.rotation.x = Math.PI / 2;
            arch.rotation.z = Math.PI / 2;
            entranceGroup.add(arch);
            
            // PIER sign
            const signText = 'PIER PARK';
            const letterWidth = 3;
            const startOffset = -(signText.length * letterWidth) / 2 + letterWidth / 2;
            
            for (let i = 0; i < signText.length; i++) {
                if (signText[i] === ' ') continue;
                const letterGeo = new THREE.BoxGeometry(2.5, 3, 0.5);
                const letterColors = [0xff6b6b, 0xffd93d, 0x6bcb77, 0x4d96ff, 0xff6b6b, 0xffd93d, 0x6bcb77, 0x4d96ff];
                const letterMat = new THREE.MeshBasicMaterial({ 
                    color: letterColors[i % letterColors.length]
                });
                const letter = new THREE.Mesh(letterGeo, letterMat);
                letter.position.set(0, 18, startOffset + i * letterWidth);
                entranceGroup.add(letter);
            }
            
            entranceGroup.position.set(x, 0, z);
            entranceGroup.rotation.y = Math.PI / 2;
            scene.add(entranceGroup);
        }
        
        function createTicketBooth(x, z) {
            const boothGroup = new THREE.Group();
            
            const boothGeo = new THREE.BoxGeometry(5, 5, 4);
            const boothMat = new THREE.MeshStandardMaterial({ 
                color: 0xff8844,
                emissive: 0xff6622,
                emissiveIntensity: 0.2
            });
            const booth = new THREE.Mesh(boothGeo, boothMat);
            booth.position.y = 2.5;
            boothGroup.add(booth);
            
            // Roof
            const roofGeo = new THREE.ConeGeometry(4, 2, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x884422 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 6;
            roof.rotation.y = Math.PI / 4;
            boothGroup.add(roof);
            
            // TICKETS sign
            const signGeo = new THREE.BoxGeometry(4.5, 1, 0.3);
            const signMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const sign = new THREE.Mesh(signGeo, signMat);
            sign.position.set(0, 4.5, 2.2);
            boothGroup.add(sign);
            
            boothGroup.position.set(x, 0, z);
            scene.add(boothGroup);
            
            // Add collision box for ticket booth
            buildings.push({
                minX: x - 3,
                maxX: x + 3,
                minZ: z - 3,
                maxZ: z + 3,
                mesh: boothGroup,
                isRide: true
            });
        }
        
        function createFoodStand(x, z, name) {
            const standGroup = new THREE.Group();
            
            // Stand body
            const standGeo = new THREE.BoxGeometry(6, 5, 4);
            const standMat = new THREE.MeshStandardMaterial({ 
                color: 0xee4466,
                emissive: 0xcc2244,
                emissiveIntensity: 0.2
            });
            const stand = new THREE.Mesh(standGeo, standMat);
            stand.position.y = 2.5;
            standGroup.add(stand);
            
            // Awning
            const awningGeo = new THREE.BoxGeometry(7, 0.5, 5);
            const awningMat = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00,
                emissive: 0xff8800,
                emissiveIntensity: 0.3
            });
            const awning = new THREE.Mesh(awningGeo, awningMat);
            awning.position.set(0, 5.5, 0.5);
            standGroup.add(awning);
            
            // Neon sign
            const signGeo = new THREE.BoxGeometry(5.5, 1.2, 0.3);
            const signMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const sign = new THREE.Mesh(signGeo, signMat);
            sign.position.set(0, 4.2, 2.2);
            standGroup.add(sign);
            
            standGroup.position.set(x, 0, z);
            scene.add(standGroup);
            
            // Add collision box for food stand
            buildings.push({
                minX: x - 4,
                maxX: x + 4,
                minZ: z - 3,
                maxZ: z + 3,
                mesh: standGroup,
                isRide: true
            });
        }
        
        function updateThemeParkRides(deltaTime) {
            const time = Date.now() * 0.001;
            
            themeParkRides.forEach(ride => {
                if (ride.type === 'ferrisWheel') {
                    // Rotate the entire ferris wheel slowly
                    ride.mesh.children.forEach(child => {
                        if (child.geometry && child.geometry.type === 'TorusGeometry') {
                            // This is the rim - rotate it
                        }
                    });
                    // Actually just rotate everything slightly
                    const rim = ride.mesh.children.find(c => c.geometry?.type === 'TorusGeometry');
                    if (rim) {
                        // Rotate gondolas around the wheel
                    }
                } else if (ride.type === 'gondola') {
                    // Update gondola position in circular motion
                    ride.angle += 0.002;
                    ride.mesh.position.set(
                        Math.cos(ride.angle) * ride.radius,
                        ride.centerY + Math.sin(ride.angle) * ride.radius,
                        0
                    );
                    // Keep gondola upright
                    ride.mesh.rotation.z = 0;
                } else if (ride.type === 'carousel') {
                    ride.mesh.rotation.y += ride.rotationSpeed;
                } else if (ride.type === 'horse') {
                    // Bob up and down
                    ride.mesh.position.y = ride.baseY + Math.sin(time * 2 + ride.phase) * 0.5;
                } else if (ride.type === 'swingRide') {
                    ride.mesh.rotation.y += ride.rotationSpeed;
                }
            });
        }

        // --- WANTED LEVEL SYSTEM ---
        function setWantedLevel(level) {
            const oldLevel = wantedLevel;
            wantedLevel = Math.max(0, Math.min(MAX_WANTED_LEVEL, level));
            updateWantedStarsUI();
            
            if (wantedLevel === 0) {
                policeCars.forEach(car => scene.remove(car.mesh));
                policeCars = [];
                policeHelicopters.forEach(heli => scene.remove(heli.mesh));
                policeHelicopters = [];
            } else if (wantedLevel > oldLevel && wantedLevel > 0) {
                for (let i = 0; i < wantedLevel * 2; i++) {
                    setTimeout(() => spawnPolice(), i * 500);
                }
            }
        }
        
        function addWantedStars(amount) {
            setWantedLevel(wantedLevel + amount);
        }
        
        function updateWantedStarsUI() {
            const stars = document.querySelectorAll('.wanted-star');
            stars.forEach((star, index) => {
                if (index < wantedLevel) {
                    if (!star.classList.contains('active')) {
                        star.classList.add('active');
                    }
                } else {
                    star.classList.remove('active');
                }
            });
        }

        // --- NPC SYSTEM WITH FEAR ---
        function createFearBarSprite() {
            // Higher resolution for crisp display
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.beginPath();
            ctx.roundRect(0, 0, 256, 32, 8);
            ctx.fill();
            
            // Border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(1, 1, 254, 30, 7);
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const spriteMat = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false,
                sizeAttenuation: true
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(2, 0.4, 1);
            sprite.visible = false;
            
            return { sprite, canvas, texture };
        }
        
        function updateFearBarSprite(npc) {
            if (!npc.fearBarCanvas) return;
            
            const canvas = npc.fearBarCanvas;
            const ctx = canvas.getContext('2d');
            const fearRatio = npc.fearLevel / 100;
            
            ctx.clearRect(0, 0, 256, 32);
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.beginPath();
            ctx.roundRect(0, 0, 256, 32, 8);
            ctx.fill();
            
            if (npc.fearLevel > 0) {
                const barWidth = Math.max(0, fearRatio * 240);
                
                // Gradient bar
                const gradient = ctx.createLinearGradient(8, 0, 248, 0);
                if (fearRatio < 0.5) {
                    gradient.addColorStop(0, '#00ff00');
                    gradient.addColorStop(1, '#ffff00');
                } else {
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(1, '#ff0000');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(8, 6, barWidth, 20, 4);
                ctx.fill();
                
                // Shine effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.roundRect(8, 6, barWidth, 8, 4);
                ctx.fill();
            }
            
            // Border
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(1, 1, 254, 30, 7);
            ctx.stroke();
            
            npc.fearBarTexture.needsUpdate = true;
        }
        
        // NPC outfit colors
        const NPC_OUTFITS = [
            { shirt: 0xff4444, pants: 0x222222 },  // Red shirt, black pants
            { shirt: 0x44ff44, pants: 0x333344 },  // Green shirt, navy pants
            { shirt: 0x4444ff, pants: 0x444444 },  // Blue shirt, gray pants
            { shirt: 0xffff44, pants: 0x222222 },  // Yellow shirt, black pants
            { shirt: 0xff44ff, pants: 0x333333 },  // Pink shirt, dark gray pants
            { shirt: 0x44ffff, pants: 0x442222 },  // Cyan shirt, brown pants
            { shirt: 0xffffff, pants: 0x000000 },  // White shirt, black pants
            { shirt: 0xff8800, pants: 0x223344 },  // Orange shirt, blue pants
            { shirt: 0x8844ff, pants: 0x333333 },  // Purple shirt, gray pants
            { shirt: 0x888888, pants: 0x222222 },  // Gray shirt, black pants
        ];
        
        const SKIN_TONES = [0xffe0bd, 0xd4a574, 0xc68642, 0x8d5524, 0x5c3317, 0xf5d0c5];
        
        // Beach outfits - swimsuits and casual beach wear
        const BEACH_OUTFITS = [
            { shirt: 0xff6b6b, pants: 0xff6b6b }, // Red swimsuit
            { shirt: 0x4ecdc4, pants: 0x4ecdc4 }, // Teal swimsuit
            { shirt: 0xffe66d, pants: 0xffe66d }, // Yellow swimsuit
            { shirt: 0xff9ff3, pants: 0xff9ff3 }, // Pink swimsuit
            { shirt: 0x54a0ff, pants: 0x54a0ff }, // Blue swimsuit
            { shirt: 0xffeaa7, pants: 0x00b894 }, // Tank top and shorts
            { shirt: 0xff7675, pants: 0x0984e3 }, // Hawaiian shirt vibes
            { shirt: 0x81ecec, pants: 0x6c5ce7 }, // Beach casual
        ];
        
        function createNPCMesh(isBeachNPC = false) {
            const npcGroup = new THREE.Group();
            
            const outfit = isBeachNPC 
                ? BEACH_OUTFITS[Math.floor(Math.random() * BEACH_OUTFITS.length)]
                : NPC_OUTFITS[Math.floor(Math.random() * NPC_OUTFITS.length)];
            const skinColor = SKIN_TONES[Math.floor(Math.random() * SKIN_TONES.length)];
            const scale = 0.9 + Math.random() * 0.3;
            
            const skinMat = new THREE.MeshStandardMaterial({ color: skinColor });
            const shirtMat = new THREE.MeshStandardMaterial({ color: outfit.shirt });
            const pantsMat = new THREE.MeshStandardMaterial({ color: outfit.pants });
            
            // Torso
            const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.25);
            const torso = new THREE.Mesh(torsoGeo, shirtMat);
            torso.position.y = 1.15;
            torso.castShadow = true;
            npcGroup.add(torso);
            
            // Head
            const headGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 0.5;
            head.castShadow = true;
            torso.add(head);
            
            // Legs (Groups for animation)
            const legGeo = new THREE.BoxGeometry(0.18, 0.8, 0.2);
            
            const leftLegGroup = new THREE.Group();
            leftLegGroup.position.set(-0.13, -0.35, 0);
            torso.add(leftLegGroup);
            const leftLeg = new THREE.Mesh(legGeo, pantsMat);
            leftLeg.position.y = -0.4;
            leftLeg.castShadow = true;
            leftLegGroup.add(leftLeg);
            
            const rightLegGroup = new THREE.Group();
            rightLegGroup.position.set(0.13, -0.35, 0);
            torso.add(rightLegGroup);
            const rightLeg = new THREE.Mesh(legGeo, pantsMat);
            rightLeg.position.y = -0.4;
            rightLeg.castShadow = true;
            rightLegGroup.add(rightLeg);
            
            // Arms (Groups for animation)
            const armGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);
            
            const leftArmGroup = new THREE.Group();
            leftArmGroup.position.set(-0.35, 0.1, 0);
            torso.add(leftArmGroup);
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.y = -0.25;
            leftArm.castShadow = true;
            leftArmGroup.add(leftArm);
            
            const rightArmGroup = new THREE.Group();
            rightArmGroup.position.set(0.35, 0.1, 0);
            torso.add(rightArmGroup);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.y = -0.25;
            rightArm.castShadow = true;
            rightArmGroup.add(rightArm);
            
            npcGroup.scale.setScalar(scale);
            
            const baseHeight = 1.9 * scale;
            const groundY = 0;
            
            // Fear bar
                const fearBar = createFearBarSprite();
            fearBar.sprite.position.set(0, baseHeight + 0.3, 0);
            npcGroup.add(fearBar.sprite);
            
            return {
                mesh: npcGroup,
                dest: new THREE.Vector3(0, groundY, 0),
                    timer: 0,
                    fearLevel: 0,
                    state: 'walking',
                    fleeDirection: null,
                originalColor: outfit.shirt,
                    screamTimer: 0,
                    interactCooldown: 0,
                    scale: scale,
                height: baseHeight,
                    groundY: groundY,
                    fearBarSprite: fearBar.sprite,
                    fearBarCanvas: fearBar.canvas,
                    fearBarTexture: fearBar.texture,
                hasAddedWantedStars: false,
                torso: torso,
                shirtMat: shirtMat,
                // Animation references
                leftLeg: leftLegGroup,
                rightLeg: rightLegGroup,
                leftArm: leftArmGroup,
                rightArm: rightArmGroup,
                animTime: Math.random() * Math.PI * 2 // Random start phase
            };
        }
        
        function spawnNPCs() {
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            
            // City NPCs
            for(let i = 0; i < 10; i++) {
                const npcData = createNPCMesh();
                
                // Spawn in city area
                const maxX = (CONFIG.gridSize - 8) * CONFIG.tileSize;
                const x = 30 + Math.random() * (maxX - 30);
                const z = Math.random() * worldSize;
                
                npcData.mesh.position.set(x, npcData.groundY, z);
                npcData.dest.set(x, npcData.groundY, z);
                npcData.isBeachNPC = false;
                scene.add(npcData.mesh);
                
                npcs.push(npcData);
            }
            
            // Beach NPCs - make the beach look popular!
            const beachStartX = (CONFIG.gridSize - 6) * CONFIG.tileSize;
            const beachEndX = CONFIG.gridSize * CONFIG.tileSize;
            
            // Calculate theme park bounds for spawn exclusion (same formula as createThemePark)
            const parkCenterX = beachStartX + 60;
            const parkCenterZ = worldSize * 0.15;
            const parkBounds = {
                minX: parkCenterX - 60,
                maxX: parkCenterX + 60,
                minZ: parkCenterZ - 50,
                maxZ: parkCenterZ + 50
            };
            
            for(let i = 0; i < 15; i++) {
                const npcData = createNPCMesh(true); // Pass true for beach outfit
                
                // Spawn on beach area - AVOID theme park platform
                let x, z;
                let attempts = 0;
                do {
                    x = beachStartX + Math.random() * (beachEndX - beachStartX - 20);
                    z = 50 + Math.random() * (worldSize - 100);
                    attempts++;
                } while (attempts < 20 && 
                         x >= parkBounds.minX - 5 && x <= parkBounds.maxX + 5 &&
                         z >= parkBounds.minZ - 5 && z <= parkBounds.maxZ + 5);
                
                npcData.mesh.position.set(x, npcData.groundY, z);
                npcData.dest.set(x, npcData.groundY, z);
                npcData.isBeachNPC = true;
                npcData.beachBounds = { minX: beachStartX, maxX: beachEndX - 20, minZ: 40, maxZ: worldSize - 40 };
                scene.add(npcData.mesh);
                
                npcs.push(npcData);
            }
        }

        // --- NPC INTERACTION SYSTEM ---
        function checkNearbyNPCs() {
            if (isInVehicle || isHotwiring || isInteractingWithNPC) return null;
            
            let nearestNPC = null;
            let nearestDistance = Infinity;
            
            npcs.forEach(npc => {
                if (npc.state === 'fleeing') return;
                if (npc.interactCooldown > 0) return;
                
                const distance = playerGroup.position.distanceTo(npc.mesh.position);
                if (distance < CONFIG.npcInteractDistance && distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestNPC = npc;
                }
            });
            
            return nearestNPC;
        }

        function startNPCInteraction(npc) {
            if (isInteractingWithNPC) return;
            
            isInteractingWithNPC = true;
            currentInteractNPC = npc;
            npc.state = 'interacting';
            
            const direction = new THREE.Vector3().subVectors(playerGroup.position, npc.mesh.position);
            npc.mesh.lookAt(playerGroup.position.x, npc.mesh.position.y, playerGroup.position.z);
            
            document.getElementById('npc-interaction-menu').style.display = 'block';
            document.getElementById('npc-interact-prompt').style.display = 'none';
            
            document.exitPointerLock();
        }

        function endNPCInteraction() {
            if (!isInteractingWithNPC || !currentInteractNPC) return;
            
            if (currentInteractNPC.state !== 'fleeing') {
                currentInteractNPC.state = 'walking';
            }
            currentInteractNPC.interactCooldown = 2;
            
            isInteractingWithNPC = false;
            currentInteractNPC = null;
            
            document.getElementById('npc-interaction-menu').style.display = 'none';
            
            document.body.requestPointerLock();
        }

        window.handleInteraction = function(type) {
            if (!currentInteractNPC) return;
            
            const npc = currentInteractNPC;
            const heightOffset = npc.height + 0.5;
            
            if (type === 'greet') {
                npc.fearLevel = Math.max(0, npc.fearLevel - 20);
                const greetText = GREET_TEXTS[Math.floor(Math.random() * GREET_TEXTS.length)];
                showFloatingText(npc.mesh.position, greetText, 'greet', heightOffset);
                updateNPCColor(npc);
                
            } else if (type === 'threaten') {
                npc.fearLevel = Math.min(100, npc.fearLevel + 35);
                const threatResponse = THREATEN_RESPONSES[Math.floor(Math.random() * THREATEN_RESPONSES.length)];
                showFloatingText(npc.mesh.position, threatResponse, 'threaten', heightOffset);
                updateNPCColor(npc);
                
                if (npc.fearLevel >= 100) {
                    triggerNPCFlee(npc);
                }
            } else if (type === 'hit') {
                hitNPC(npc);
                return; // Don't end interaction yet - can keep hitting
            }
            
            endNPCInteraction();
        };
        
        // NPC hit/death system
        function hitNPC(npc) {
            if (!npc.hitCount) npc.hitCount = 0;
            npc.hitCount++;
            
            const damage = 20 + Math.floor(Math.random() * 15);
            const heightOffset = npc.height + 0.5;
            showFloatingText(npc.mesh.position, '-' + damage, 'damage', heightOffset);
            
            // NPC reacts to being hit
            npc.fearLevel = 100;
            updateNPCColor(npc);
            
            // Random hits to kill (2-5)
            const hitsToKill = npc.hitsToKill || (2 + Math.floor(Math.random() * 4));
            npc.hitsToKill = hitsToKill;
            
            if (npc.hitCount >= hitsToKill) {
                // NPC dies
                killNPC(npc);
            } else {
                // NPC screams
                const screamText = SCREAM_TEXTS[Math.floor(Math.random() * SCREAM_TEXTS.length)];
                setTimeout(() => {
                    showFloatingText(npc.mesh.position, screamText, 'scream', heightOffset);
                }, 200);
            }
            
            // Increase wanted level
            if (!npc.hasAddedWantedStars) {
                npc.hasAddedWantedStars = true;
                addWantedStars(1);
            }
        }
        
        function killNPC(npc) {
            endNPCInteraction();
            
            // Give player money
            const cashEarned = 1 + Math.floor(Math.random() * 150);
            playerCash += cashEarned;
            updateCashDisplay();
            
            const heightOffset = npc.height + 0.5;
            showFloatingText(npc.mesh.position, '+$' + cashEarned, 'greet', heightOffset);
            
            // NPC falls over (rotate to lie down)
            npc.state = 'dead';
            npc.mesh.rotation.x = Math.PI / 2;
            npc.mesh.position.y = 0.3;
            
            // Hide fear bar
            if (npc.fearBarSprite) {
                npc.fearBarSprite.visible = false;
            }
            
            // Remove NPC after delay
            setTimeout(() => {
                scene.remove(npc.mesh);
                const idx = npcs.indexOf(npc);
                if (idx > -1) npcs.splice(idx, 1);
                
                // Spawn a new NPC to replace
                spawnSingleNPC();
            }, 5000);
            
            // Add wanted stars for killing
            addWantedStars(1);
        }
        
        function spawnSingleNPC() {
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            
            // 40% chance to spawn beach NPC
            const isBeach = Math.random() < 0.4;
            const npcData = createNPCMesh(isBeach);
            
            if (isBeach) {
                // Beach NPC
                const beachStartX = (CONFIG.gridSize - 6) * CONFIG.tileSize;
                const beachEndX = CONFIG.gridSize * CONFIG.tileSize;
                const x = beachStartX + Math.random() * (beachEndX - beachStartX - 30);
                const z = 50 + Math.random() * (worldSize - 100);
                
                npcData.mesh.position.set(x, npcData.groundY, z);
                npcData.isBeachNPC = true;
                npcData.beachBounds = { minX: beachStartX, maxX: beachEndX - 30, minZ: 40, maxZ: worldSize - 40 };
            } else {
                // City NPC
                const maxX = (CONFIG.gridSize - 8) * CONFIG.tileSize;
                const x = 50 + Math.random() * (maxX - 50);
                const z = Math.random() * worldSize;
                
                npcData.mesh.position.set(x, npcData.groundY, z);
                npcData.isBeachNPC = false;
            }
            
            scene.add(npcData.mesh);
            npcs.push(npcData);
        }

        function updateNPCColor(npc) {
            const fearRatio = npc.fearLevel / 100;
            const originalColor = new THREE.Color(npc.originalColor);
            const fearColor = new THREE.Color(0xff0000);
            
            // Update shirt color based on fear
            if (npc.shirtMat) {
                npc.shirtMat.color.copy(originalColor).lerp(fearColor, fearRatio * 0.5);
            } else if (npc.mesh.material) {
            npc.mesh.material.color.copy(originalColor).lerp(fearColor, fearRatio * 0.5);
            }
        }

        function triggerNPCFlee(npc) {
            npc.state = 'fleeing';
            npc.fearLevel = 100;
            
            if (!npc.hasAddedWantedStars) {
                npc.hasAddedWantedStars = true;
                addWantedStars(1); // Frightening locals adds stars
            }
            
            const fleeDir = new THREE.Vector3().subVectors(npc.mesh.position, playerGroup.position).normalize();
            npc.fleeDirection = fleeDir;
            
            const screamText = SCREAM_TEXTS[Math.floor(Math.random() * SCREAM_TEXTS.length)];
            const heightOffset = npc.height + 0.5;
            showFloatingText(npc.mesh.position, screamText, 'scream', heightOffset);
            
            propagateFear(npc);
        }

        function propagateFear(sourceNPC) {
            npcs.forEach(npc => {
                if (npc === sourceNPC) return;
                if (npc.state === 'fleeing') return;
                
                const distance = npc.mesh.position.distanceTo(sourceNPC.mesh.position);
                
                if (distance < CONFIG.fearPropagationRadius) {
                    const fearIncrease = CONFIG.fearPropagationAmount * (1 - distance / CONFIG.fearPropagationRadius);
                    npc.fearLevel = Math.min(100, npc.fearLevel + fearIncrease);
                    
                    updateNPCColor(npc);
                    
                    if (npc.fearLevel >= 100) {
                        setTimeout(() => {
                            if (npc.state !== 'fleeing') {
                                triggerNPCFlee(npc);
                            }
                        }, 200 + Math.random() * 300);
                    }
                }
            });
        }

        function showFloatingText(position, text, type, heightOffset = 2.5) {
            const floatingText = document.createElement('div');
            floatingText.className = `floating-text ${type}`;
            floatingText.textContent = text;
            
            const screenPos = toScreenPosition(position, camera, heightOffset);
            floatingText.style.left = screenPos.x + 'px';
            floatingText.style.top = (screenPos.y - 50) + 'px';
            
            document.body.appendChild(floatingText);
            
            setTimeout(() => {
                floatingText.remove();
            }, 1500);
        }

        function toScreenPosition(position, camera, heightOffset = 2.5) {
            const vector = position.clone();
            vector.y += heightOffset;
            vector.project(camera);
            
            return {
                x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                y: (-vector.y * 0.5 + 0.5) * window.innerHeight
            };
        }

        // --- INPUT ---
        function onKeyDown(e) {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.code === 'Space') keys.space = true;
            if (e.code === 'ShiftLeft') keys.shift = true;
            if (e.code === 'KeyE') keys.e = true;
            if (e.code === 'KeyF') keys.f = true;
            if (e.code === 'KeyQ') keys.q = true;
            if (e.code === 'KeyR') reloadWeapon();
            
            if (e.code === 'KeyV') {
                if (isInVehicle) {
                    const modes = ['vehicle', 'vehicle-hood'];
                    const currentIndex = modes.indexOf(cameraMode);
                    cameraMode = modes[(currentIndex + 1) % modes.length];
                } else {
                    cameraMode = (cameraMode === 'third') ? 'first' : 'third';
                    // Hide all player parts in first person
                    playerGroup.traverse((child) => {
                        if (child.isMesh) {
                            child.visible = (cameraMode === 'third');
                        }
                    });
                    updateWeaponVisuals();
                }
            }

            if (e.code === 'ArrowUp') {
                togglePhone();
            }
            
            // Exit vehicle
            if (e.code === 'KeyF' && isInVehicle) {
                exitVehicle();
            }
            
            // Inventory
            if (e.code === 'KeyQ') {
                toggleInventory();
            }
            
            // Interaction menu shortcuts
            if (isInteractingWithNPC) {
                if (e.code === 'Digit1' || e.code === 'Numpad1') {
                    handleInteraction('greet');
                } else if (e.code === 'Digit2' || e.code === 'Numpad2') {
                    handleInteraction('threaten');
                } else if (e.code === 'Digit3' || e.code === 'Numpad3') {
                    handleInteraction('hit');
                } else if (e.code === 'Escape') {
                    endNPCInteraction();
                }
            }
            
            // NOCLIP CINEMATIC MODE - X to activate, Z to deactivate
            if (e.code === 'KeyX') {
                const now = Date.now();
                if (isNoclipMode && noclipSpeed === 1 && now - lastXPress < 500) {
                    // Double tap X - ultra slow mode
                    noclipSpeed = 2;
                    showNoclipNotification('CINEMATIC MODE: Ultra Slow');
                } else if (!isNoclipMode) {
                    // First press - enable regular slow mode
                    isNoclipMode = true;
                    noclipSpeed = 1;
                    noclipPosition.copy(camera.position);
                    noclipCurrentYaw = yaw;
                    noclipCurrentPitch = pitch;
                    noclipTargetYaw = yaw;
                    noclipTargetPitch = pitch;
                    showNoclipNotification('CINEMATIC MODE: Slow');
                    document.body.requestPointerLock();
                } else if (noclipSpeed === 2) {
                    // Already in ultra slow, go back to slow
                    noclipSpeed = 1;
                    showNoclipNotification('CINEMATIC MODE: Slow');
                }
                lastXPress = now;
            }
            
            if (e.code === 'KeyZ' && isNoclipMode) {
                // Deactivate noclip
                isNoclipMode = false;
                noclipSpeed = 0;
                showNoclipNotification('CINEMATIC MODE: Off');
            }
        }
        
        function onKeyUp(e) {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
            if (e.code === 'ShiftLeft') keys.shift = false;
            if (e.code === 'KeyE') keys.e = false;
            if (e.code === 'KeyF') keys.f = false;
            if (e.code === 'KeyQ') keys.q = false;
        }
        
        function onMouseMove(e) {
            if (document.pointerLockElement === document.body && !isPhoneOpen && !isInteractingWithNPC && !isInventoryOpen) {
                const sensitivity = 0.002;
                
                if (isNoclipMode) {
                    // Cinematic mode - update target angles (camera will smoothly follow)
                    noclipTargetYaw -= e.movementX * sensitivity;
                    noclipTargetPitch -= e.movementY * sensitivity;
                    noclipTargetPitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, noclipTargetPitch));
                } else {
                    // Normal mode
                yaw -= e.movementX * sensitivity;
                pitch -= e.movementY * sensitivity;
                // Allow looking nearly straight up/down (¬±85 degrees)
                pitch = Math.max(-Math.PI / 2.1, Math.min(Math.PI / 2.1, pitch));
                
                if (playerArm) playerArm.rotation.x = pitch;
                }

                if (isInVehicle && currentVehicle && !isNoclipMode) {
                    currentVehicle.rotation -= e.movementX * 0.001;
                }
            }
        }

        // --- COLLISION DETECTION ---
        function checkCollision(x, z) {
            if (x < 5 || z < 5 || x > CONFIG.gridSize * CONFIG.tileSize - 5 || z > CONFIG.gridSize * CONFIG.tileSize - 5) {
                return true;
            }

            for (let b of buildings) {
                if (x > b.minX && x < b.maxX && z > b.minZ && z < b.maxZ) {
                    return true;
                }
            }
            
            if (!isInVehicle) {
                for (let car of cars) {
                    if (car.isPlayerControlled) continue;
                    
                    const carPos = car.mesh.position;
                    const carWidth = car.dimensions.width;
                    const carLength = car.dimensions.length;
                    
                    const minX = carPos.x - carWidth/2;
                    const maxX = carPos.x + carWidth/2;
                    const minZ = carPos.z - carLength/2;
                    const maxZ = carPos.z + carLength/2;
                    
                    if (x > minX && x < maxX && z > minZ && z < maxZ) {
                        return true;
                    }
                }
            }

            // 4. PLAYER vs NPC COLLISION
            if (!isInVehicle) {
                for (let npc of npcs) {
                    const dist = Math.sqrt((x - npc.mesh.position.x)**2 + (z - npc.mesh.position.z)**2);
                    if (dist < 1.0) { 
                        return true;
                    }
                }
            }
            
            return false;
        }

        // --- VEHICLE CONTROLS ---
        function updateVehicleControls(deltaTime) {
            if (!isInVehicle || !currentVehicle || isInventoryOpen) return;
            
            const car = currentVehicle;
            
            // W = forward, S = backward
            if (keys.w) {
                car.speed = THREE.MathUtils.lerp(car.speed, car.maxSpeed, car.acceleration);
            } else if (keys.s) {
                car.speed = THREE.MathUtils.lerp(car.speed, -car.maxSpeed * 0.5, car.acceleration);
            } else {
                car.speed = THREE.MathUtils.lerp(car.speed, 0, 0.05);
            }
            
            if (keys.space) {
                car.speed = THREE.MathUtils.lerp(car.speed, 0, 0.1);
            }
            
            // A = left, D = right (fixed)
            if (Math.abs(car.speed) > 0.01) {
                if (keys.a) {
                    car.rotation += car.handling * Math.sign(car.speed);
                }
                if (keys.d) {
                    car.rotation -= car.handling * Math.sign(car.speed);
                }
            }
            
            if (keys.shift) {
                car.speed = THREE.MathUtils.lerp(car.speed, car.maxSpeed * 1.3, 0.02);
            }
            
            car.mesh.rotation.y = car.rotation;
            
            // Forward direction (positive Z is forward for car)
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
            
            const newPos = car.mesh.position.clone().add(forward.multiplyScalar(car.speed));
            
            if (!checkCollision(newPos.x, newPos.z)) {
                car.mesh.position.copy(newPos);
            } else {
                car.speed = 0;
            }
            
            const speedMph = Math.abs(car.speed * 80).toFixed(0);
            document.getElementById('vehicle-speed').textContent = speedMph;
            
            updateVehicleCamera(car);
        }

        function updateVehicleCamera(car) {
            const carPos = car.mesh.position;
            
            if (cameraMode === 'vehicle') {
                // Camera behind car (positive Z is forward, so negative Z offset puts camera behind)
                const offset = new THREE.Vector3(0, 4, -10);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                
                camera.position.lerp(carPos.clone().add(offset), 0.1);
                camera.lookAt(carPos.x, carPos.y + 1.5, carPos.z);
                
            } else if (cameraMode === 'vehicle-hood') {
                // Hood cam - in front of car looking forward
                const offset = new THREE.Vector3(0, 1.8, 3);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                
                camera.position.copy(carPos).add(offset);
                
                const lookAt = new THREE.Vector3(0, 0, 50);
                lookAt.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                camera.lookAt(carPos.clone().add(lookAt));
            }
        }

        // --- PLAYER UPDATE ---
        function updatePlayer(deltaTime) {
            if (isPhoneOpen || isInVehicle || isInteractingWithNPC || isInventoryOpen) return;

            handleShooting(deltaTime);

            const speed = keys.shift ? CONFIG.runSpeed : CONFIG.walkSpeed;
            const dir = new THREE.Vector3();

            if (keys.w) dir.z -= 1;
            if (keys.s) dir.z += 1;
            if (keys.a) dir.x -= 1;
            if (keys.d) dir.x += 1;

            const isMoving = dir.lengthSq() > 0;
            const isSprinting = isMoving && keys.shift;
            
            // Update animation
            updatePlayerAnimation(deltaTime, isMoving, isSprinting);

            if (isMoving) {
                dir.normalize();
                dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                const nextX = playerGroup.position.x + dir.x * speed;
                const nextZ = playerGroup.position.z + dir.z * speed;

                // Check if target position is on stairs or platform (allows walking there)
                const targetOnStairsOrPlatform = isOnStairsOrPlatform(nextX, nextZ);
                const currentOnStairsOrPlatform = isOnStairsOrPlatform(playerGroup.position.x, playerGroup.position.z);
                
                // Allow movement if: no collision, OR moving onto/on stairs/platform
                if (!checkCollision(nextX, playerGroup.position.z) || 
                    isOnStairsOrPlatform(nextX, playerGroup.position.z)) {
                    playerGroup.position.x = nextX;
                }
                if (!checkCollision(playerGroup.position.x, nextZ) || 
                    isOnStairsOrPlatform(playerGroup.position.x, nextZ)) {
                    playerGroup.position.z = nextZ;
                }

                const angle = Math.atan2(dir.x, dir.z);
                playerGroup.rotation.y = angle + Math.PI; 
            }
            
            // Update player Y position based on stairs/platform
            const targetY = getStairHeight(playerGroup.position.x, playerGroup.position.z);
            playerGroup.position.y = THREE.MathUtils.lerp(playerGroup.position.y, targetY, 0.2);

            const nearbyNPC = checkNearbyNPCs();
            const nearbyCar = checkNearbyVehicles();
            
            if (nearbyNPC && !isHotwiring) {
                document.getElementById('npc-interact-prompt').style.display = 'block';
                document.getElementById('enter-prompt').style.display = 'none';
                
                if (keys.e) {
                    startNPCInteraction(nearbyNPC);
                }
            } else if (nearbyCar && !isHotwiring) {
                document.getElementById('enter-prompt').style.display = 'block';
                document.getElementById('npc-interact-prompt').style.display = 'none';
                
                if (keys.e) {
                    if (nearbyCar.entered) {
                        enterVehicle(nearbyCar);
                    } else {
                        startHotwiring(nearbyCar);
                    }
                }
            } else {
                document.getElementById('enter-prompt').style.display = 'none';
                document.getElementById('npc-interact-prompt').style.display = 'none';
            }

            if (cameraMode === 'third') {
                // Closer camera for better visibility
                const camDistance = 3.5;
                const camHeight = 2.0;
                const camX = playerGroup.position.x + camDistance * Math.sin(yaw) * Math.cos(pitch);
                const camZ = playerGroup.position.z + camDistance * Math.cos(yaw) * Math.cos(pitch);
                const camY = playerGroup.position.y + camHeight + 2 * Math.sin(pitch);
                
                camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.12);
                const lookTarget = playerGroup.position.clone();
                lookTarget.y += 1.2;
                camera.lookAt(lookTarget);
                
                if (playerArm) playerArm.lookAt(camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(100)));

            } else if (cameraMode === 'first') {
                const camX = playerGroup.position.x;
                const camZ = playerGroup.position.z;
                const camY = playerGroup.position.y + 1.6;
                camera.position.set(camX, camY, camZ);
                
                // Proper first person look direction using both yaw and pitch
                const lookDistance = 10;
                const lookTarget = new THREE.Vector3(
                    camX - Math.sin(yaw) * Math.cos(pitch) * lookDistance,
                    camY + Math.sin(pitch) * lookDistance,
                    camZ - Math.cos(yaw) * Math.cos(pitch) * lookDistance
                );
                camera.lookAt(lookTarget);
            }
        }

        // --- SHOOTING MECHANICS ---
        function handleShooting(deltaTime) {
            const weapon = WEAPON_STATS[currentWeapon];
            if (!weapon || weapon.type !== 'gun') return;

            if (isMouseDown) {
                const now = Date.now();
                if (now - lastFireTime > weapon.fireRate) {
                    if (weapon.automatic || !keys.shotLocked) {
                        shootWeapon(weapon);
                        lastFireTime = now;
                        if (!weapon.automatic) keys.shotLocked = true;
                    }
                }
            } else {
                keys.shotLocked = false;
            }
        }

        function shootWeapon(weapon) {
            if (wantedLevel < 1) addWantedStars(1);

            createMuzzleFlash();

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            const startPoint = playerGroup.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            if (playerGun) {
                 const gunWorldPos = new THREE.Vector3();
                 playerGun.getWorldPosition(gunWorldPos);
                 startPoint.copy(gunWorldPos);
            }
            
            let endPoint = startPoint.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(weapon.range));
            
            for (let hit of intersects) {
                let isPlayer = false;
                let obj = hit.object;
                while(obj) {
                    if(obj === playerGroup) { isPlayer = true; break; }
                    obj = obj.parent;
                }
                if (isPlayer) continue;

                endPoint = hit.point;
                createImpact(hit.point, hit.object);
                applyDamage(hit.object, weapon.damage);
                break;
            }

            createBulletTracer(startPoint, endPoint);
        }

        function createMuzzleFlash() {
             const flash = new THREE.PointLight(0xffff00, 5, 4);
             if (playerGun) {
                 const gunPos = new THREE.Vector3();
                 playerGun.getWorldPosition(gunPos);
                 const dir = new THREE.Vector3();
                 playerGun.getWorldDirection(dir);
                 gunPos.add(dir.multiplyScalar(0.5));
                 
                 flash.position.copy(gunPos);
             } else {
                 flash.position.copy(playerGroup.position).add(new THREE.Vector3(0, 1.5, 0));
             }
             
             scene.add(flash);
             setTimeout(() => scene.remove(flash), 50);
        }

        function createBulletTracer(start, end) {
            const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const points = [start, end];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            let op = 1;
            const animateTracer = () => {
                op -= 0.1;
                material.opacity = op;
                material.transparent = true;
                if (op <= 0) {
                    scene.remove(line);
                    geometry.dispose();
                    material.dispose();
                } else {
                    requestAnimationFrame(animateTracer);
                }
            };
            animateTracer();
        }

        function createImpact(point, object) {
            const particleCount = 5;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for(let i=0; i<particleCount; i++) {
                positions.push(point.x, point.y, point.z);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.2 });
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            const vels = [];
            for(let i=0; i<particleCount; i++) {
                vels.push(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2));
            }
            
            const animateImpact = () => {
                const pos = particles.geometry.attributes.position.array;
                let alive = false;
                for(let i=0; i<particleCount; i++) {
                     pos[i*3] += vels[i].x;
                     pos[i*3+1] += vels[i].y;
                     pos[i*3+2] += vels[i].z;
                     if(Math.abs(vels[i].x) > 0.001) alive = true;
                     vels[i].multiplyScalar(0.9);
                }
                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity -= 0.05;
                material.transparent = true;
                
                if (material.opacity > 0) {
                    requestAnimationFrame(animateImpact);
                } else {
                    scene.remove(particles);
                }
            };
            animateImpact();
        }

        function applyDamage(object, amount) {
            let target = object;
            let policeUnit = null;
            
            while(target) {
                if (target.userData && target.userData.parentCar) {
                    policeUnit = target.userData.parentCar;
                    break;
                }
                if (target.userData && target.userData.isHelicopter) {
                    policeUnit = target.userData;
                    break;
                }
                target = target.parent;
            }

            if (policeUnit) {
                if (policeUnit.mesh) {
                    policeUnit.mesh.traverse((child) => {
                         if (child.isMesh && child.material) {
                             if (!child.userData.origColor) child.userData.origColor = child.material.color.getHex();
                             child.material.color.setHex(0xff0000);
                             setTimeout(() => {
                                 if (child.material) child.material.color.setHex(child.userData.origColor);
                             }, 100);
                         }
                    });
                }
                
                if (policeUnit.health !== undefined) {
                    policeUnit.health -= amount;
                    showFloatingText(policeUnit.mesh.position, `-${amount}`, 'damage', 4);
                    
                    if (policeUnit.health <= 0) {
                        destroyPoliceUnit(policeUnit);
                    }
                }
            }
        }
        
        function destroyPoliceUnit(unit) {
            createExplosion(unit.mesh.position);
            scene.remove(unit.mesh);
            if (unit.type && unit.type === 'helicopter') {
                const idx = policeHelicopters.indexOf(unit);
                if (idx > -1) policeHelicopters.splice(idx, 1);
            } else {
                const idx = policeCars.indexOf(unit);
                if (idx > -1) policeCars.splice(idx, 1);
            }
            addWantedStars(1);
        }

        function createExplosion(pos) {
             const geometry = new THREE.SphereGeometry(2, 8, 8);
             const material = new THREE.MeshBasicMaterial({ color: 0xff4400 });
             const explosion = new THREE.Mesh(geometry, material);
             explosion.position.copy(pos);
             scene.add(explosion);
             
             let scale = 1.0;
             const animExplosion = () => {
                 scale += 0.2;
                 explosion.scale.setScalar(scale);
                 material.opacity -= 0.05;
                 material.transparent = true;
                 if (material.opacity > 0) {
                     requestAnimationFrame(animExplosion);
                 } else {
                     scene.remove(explosion);
                 }
             };
             animExplosion();
        }
        
        function reloadWeapon() {
        }

        // NPC animation helper
        function updateNPCAnimation(npc, deltaTime, isMoving, isFleeing) {
            if (!npc.leftLeg || !npc.rightLeg) return;
            
            const animSpeed = isFleeing ? 18 : (isMoving ? 10 : 0);
            const animAmplitude = isFleeing ? 0.9 : (isMoving ? 0.5 : 0);
            
            if (isMoving || isFleeing) {
                npc.animTime += deltaTime * animSpeed;
                
                // Leg swing
                npc.leftLeg.rotation.x = Math.sin(npc.animTime) * animAmplitude;
                npc.rightLeg.rotation.x = Math.sin(npc.animTime + Math.PI) * animAmplitude;
                
                // Arm swing (opposite to legs)
                if (npc.leftArm && npc.rightArm) {
                    npc.leftArm.rotation.x = Math.sin(npc.animTime + Math.PI) * animAmplitude * 0.6;
                    npc.rightArm.rotation.x = Math.sin(npc.animTime) * animAmplitude * 0.6;
                }
                
                // Torso bob
                if (npc.torso) {
                    npc.torso.position.y = 1.15 + Math.abs(Math.sin(npc.animTime * 2)) * 0.03;
                }
            } else {
                // Idle - gentle breathing
                npc.animTime += deltaTime * 2;
                
                npc.leftLeg.rotation.x = THREE.MathUtils.lerp(npc.leftLeg.rotation.x, 0, 0.1);
                npc.rightLeg.rotation.x = THREE.MathUtils.lerp(npc.rightLeg.rotation.x, 0, 0.1);
                
                if (npc.leftArm && npc.rightArm) {
                    npc.leftArm.rotation.x = THREE.MathUtils.lerp(npc.leftArm.rotation.x, 0, 0.1);
                    npc.rightArm.rotation.x = THREE.MathUtils.lerp(npc.rightArm.rotation.x, 0, 0.1);
                }
                
                if (npc.torso) {
                    npc.torso.position.y = 1.15 + Math.sin(npc.animTime) * 0.01;
                }
            }
        }

        function updateNPCs(deltaTime) {
            npcs.forEach(npc => {
                if (npc.interactCooldown > 0) {
                    npc.interactCooldown -= deltaTime;
                }
                
                if (npc.state !== 'fleeing' && npc.fearLevel > 0) {
                    npc.fearLevel = Math.max(0, npc.fearLevel - deltaTime * 2);
                    updateNPCColor(npc);
                }
                
                updateFearBarSprite(npc);
                
                if (npc.fearBarSprite) {
                    npc.fearBarSprite.visible = npc.fearLevel > 0;
                }
                
                if (npc.state === 'interacting') {
                    // Idle animation when talking
                    updateNPCAnimation(npc, deltaTime, false, false);
                    return;
                }
                
                if (npc.state === 'fleeing') {
                    // Flee speed - time-based (units per second)
                    const fleeSpeed = 8 * deltaTime;
                    const newPos = npc.mesh.position.clone().add(
                        npc.fleeDirection.clone().multiplyScalar(fleeSpeed)
                    );
                    newPos.y = npc.groundY;
                    
                    if (!checkCollision(newPos.x, newPos.z)) {
                        npc.mesh.position.copy(newPos);
                    } else {
                        npc.fleeDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
                    }
                    
                    npc.mesh.lookAt(
                        npc.mesh.position.x + npc.fleeDirection.x,
                        npc.mesh.position.y,
                        npc.mesh.position.z + npc.fleeDirection.z
                    );
                    
                    // Running animation when fleeing
                    updateNPCAnimation(npc, deltaTime, true, true);
                    
                    npc.screamTimer += deltaTime;
                    if (npc.screamTimer > 2) {
                        npc.screamTimer = 0;
                        const screamText = SCREAM_TEXTS[Math.floor(Math.random() * SCREAM_TEXTS.length)];
                        const heightOffset = npc.height + 0.5;
                        showFloatingText(npc.mesh.position, screamText, 'scream', heightOffset);
                        propagateFear(npc);
                    }
                    
                    const distanceToPlayer = npc.mesh.position.distanceTo(playerGroup.position);
                    if (distanceToPlayer > 40) {
                        npc.state = 'walking';
                        npc.fearLevel = 50;
                        npc.hasAddedWantedStars = false;
                        updateNPCColor(npc);
                    }
                    return;
                }
                
                if (npc.mesh.position.distanceTo(npc.dest) < 2) {
                    // Set new destination based on NPC type
                    if (npc.isBeachNPC && npc.beachBounds) {
                        // Beach NPCs stay on beach - pick destination outside theme park
                        let attempts = 0;
                        let bx, bz;
                        do {
                            bx = npc.beachBounds.minX + Math.random() * (npc.beachBounds.maxX - npc.beachBounds.minX);
                            bz = npc.beachBounds.minZ + Math.random() * (npc.beachBounds.maxZ - npc.beachBounds.minZ);
                            attempts++;
                        } while (attempts < 10 && themeParkBounds && 
                                 bx >= themeParkBounds.minX && bx <= themeParkBounds.maxX &&
                                 bz >= themeParkBounds.minZ && bz <= themeParkBounds.maxZ);
                        npc.dest.set(bx, npc.groundY, bz);
                    } else {
                        // City NPCs stay in city
                        const worldSize = CONFIG.gridSize * CONFIG.tileSize;
                        const maxX = (CONFIG.gridSize - 8) * CONFIG.tileSize;
                        const bx = 30 + Math.random() * (maxX - 30);
                        const bz = Math.random() * worldSize;
                        npc.dest.set(bx, npc.groundY, bz);
                    }
                }
                
                const dir = new THREE.Vector3().subVectors(npc.dest, npc.mesh.position).normalize();
                // Walking speed - time-based (units per second)
                const baseWalkSpeed = npc.isBeachNPC ? 2.5 : 3.0;
                const walkSpeed = baseWalkSpeed * deltaTime;
                const newPos = npc.mesh.position.clone().add(dir.multiplyScalar(walkSpeed));
                newPos.y = npc.groundY;
                
                // Beach NPCs skip collision check with theme park platform, city NPCs check all
                let canMove = true;
                if (npc.isBeachNPC) {
                    // Beach NPCs only check world bounds, not buildings
                    const worldSize = CONFIG.gridSize * CONFIG.tileSize;
                    if (newPos.x < 5 || newPos.z < 5 || newPos.x > worldSize - 5 || newPos.z > worldSize - 5) {
                        canMove = false;
                    }
                    // Check if trying to enter theme park platform
                    if (themeParkBounds && 
                        newPos.x >= themeParkBounds.minX && newPos.x <= themeParkBounds.maxX &&
                        newPos.z >= themeParkBounds.minZ && newPos.z <= themeParkBounds.maxZ) {
                        canMove = false;
                        // Pick a new destination to walk around the platform
                        npc.dest.set(npc.mesh.position.x, npc.groundY, npc.mesh.position.z);
                    }
                } else {
                    canMove = !checkCollision(newPos.x, newPos.z);
                }
                
                if (canMove) {
                    npc.mesh.position.copy(newPos);
                    // Walking animation
                    updateNPCAnimation(npc, deltaTime, true, false);
                } else {
                    // Pick new destination when stuck
                    npc.dest.copy(npc.mesh.position);
                    updateNPCAnimation(npc, deltaTime, false, false);
                }
                
                npc.mesh.lookAt(npc.dest.x, npc.mesh.position.y, npc.dest.z);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function togglePhone() {
            isPhoneOpen = !isPhoneOpen;
            const el = document.getElementById('phone-container');
            if (isPhoneOpen) {
                el.classList.add('active');
                document.exitPointerLock();
                document.getElementById('app-display').innerText = "Select an App";
            } else {
                el.classList.remove('active');
                document.body.requestPointerLock();
            }
        }

        window.openApp = function(appName) {
            const display = document.getElementById('app-display');
            if (appName === 'TokTik') display.innerText = "üéµ Playing trending dance video...";
            if (appName === 'Insta') display.innerText = "üì∑ Liked your friend's beach photo.";
            if (appName === 'Tube') display.innerText = "‚ñ∂Ô∏è Watching 'Funny Cat Compilation #42'";
            if (appName === 'Maps') display.innerText = "üó∫Ô∏è You are at Vice Beach.";
        };

        // === NEW POLICE SYSTEM FUNCTIONS ===
        function createPoliceCar() {
            const car = createCar('SEDAN');
            car.health = 100;
            
            // Make police car larger (1.3x scale)
            car.mesh.scale.setScalar(1.3);
            
            // Police paint job - dark blue
            car.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (child.material.color && child.material.color.getHex() !== 0x1a1a1a) {
                        child.material = new THREE.MeshStandardMaterial({ 
                            color: 0x000066, 
                            roughness: 0.25, 
                            metalness: 0.8 
                        });
                    }
                }
            });
            
            // White door stripes
            const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const stripeGeo = new THREE.BoxGeometry(0.05, 0.6, 1.8);
            
            const stripe1 = new THREE.Mesh(stripeGeo, stripeMat);
            stripe1.position.set(0.95, 0.7, 0);
            car.mesh.add(stripe1);
            
            const stripe2 = new THREE.Mesh(stripeGeo, stripeMat);
            stripe2.position.set(-0.95, 0.7, 0);
            car.mesh.add(stripe2);
            
            // Light bar on roof
            const sirenBase = new THREE.Mesh(
                new THREE.BoxGeometry(1.4, 0.25, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8 })
            );
            sirenBase.position.set(0, 1.5, -0.2);
            car.mesh.add(sirenBase);
            
            // Larger siren lights
            const redLight = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            redLight.position.set(-0.4, 0.2, 0);
            sirenBase.add(redLight);
            
            const blueLight = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0x0000ff })
            );
            blueLight.position.set(0.4, 0.2, 0);
            sirenBase.add(blueLight);
            
            // Push bar at front
            const pushBar = new THREE.Mesh(
                new THREE.BoxGeometry(1.6, 0.4, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9 })
            );
            pushBar.position.set(0, 0.4, 2.3);
            car.mesh.add(pushBar);
            
            car.isPolice = true;
            car.state = 'searching';
            car.searchStartTime = Date.now();
            car.lastShotTime = 0;
            car.lastYellTime = 0;
            car.sirenLights = { red: redLight, blue: blueLight };
            
            car.mesh.userData = { parentCar: car };
            
            return car;
        }

        function createPoliceHelicopter() {
            const heliGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.5, 2),
                new THREE.MeshStandardMaterial({ color: 0x000080 })
            );
            body.position.y = 0.75;
            heliGroup.add(body);
            
            const cockpit = new THREE.Mesh(
                new THREE.SphereGeometry(1, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333, transparent: true, opacity: 0.7 })
            );
            cockpit.position.y = 1;
            cockpit.scale.set(1.5, 0.7, 1);
            heliGroup.add(cockpit);
            
            const rotor = new THREE.Mesh(
                new THREE.BoxGeometry(8, 0.1, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            rotor.position.y = 2;
            heliGroup.add(rotor);
            
            const tailRotor = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.1, 2),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            tailRotor.position.set(-4, 1.5, 0);
            heliGroup.add(tailRotor);
            
            heliGroup.position.y = CONFIG.policeHelicopterAltitude;
            
            const heliObj = {
                mesh: heliGroup,
                rotor: rotor,
                tailRotor: tailRotor,
                state: 'searching',
                lastShotTime: 0,
                searchStartTime: Date.now(),
                health: 150, 
                type: 'helicopter',
                isHelicopter: true 
            };
            
            heliGroup.userData = heliObj;
            
            return heliObj;
        }

        function spawnPolice() {
            if (wantedLevel === 0) return;
            
            const now = Date.now();
            if (now - lastPoliceSpawn < CONFIG.policeSpawnDelay) return;
            
            let maxPolice = 0;
            let spawnHelicopter = false;
            let spawnTank = false;
            
            switch(wantedLevel) {
                case 1: maxPolice = 2; break;
                case 2: maxPolice = 4; break;
                case 3: maxPolice = 4; break;
                case 4: maxPolice = 8; spawnHelicopter = true; break;
                case 5: maxPolice = 12; spawnHelicopter = true; spawnTank = true; break;
            }
            
            if (policeCars.length < maxPolice) {
                const spawnTile = roadTiles[Math.floor(Math.random() * roadTiles.length)];
                const policeCar = createPoliceCar();
                
                policeCar.mesh.position.set(
                    spawnTile.x * CONFIG.tileSize + (Math.random() - 0.5) * 5,
                    0.7 * policeCar.dimensions.height,
                    spawnTile.z * CONFIG.tileSize + (Math.random() - 0.5) * 5
                );
                
                scene.add(policeCar.mesh);
                policeCars.push(policeCar);
                lastPoliceSpawn = now;
            }
            
            if (spawnHelicopter && policeHelicopters.length === 0) {
                const heli = createPoliceHelicopter();
                scene.add(heli.mesh);
                policeHelicopters.push(heli);
            }
        }

        function despawnPoliceUnit(unit, index, type) {
            scene.remove(unit.mesh);
            if (type === 'car') {
                policeCars.splice(index, 1);
            } else if (type === 'helicopter') {
                policeHelicopters.splice(index, 1);
            }
        }

        function updatePoliceAI(deltaTime) {
            const playerPos = isInVehicle ? currentVehicle?.mesh.position : playerGroup.position;
            if (!playerPos) return;
            
            for (let i = policeCars.length - 1; i >= 0; i--) {
                const policeCar = policeCars[i];
                const distance = policeCar.mesh.position.distanceTo(playerPos);
                const searchDuration = (Date.now() - policeCar.searchStartTime) / 1000;
                const maxSearchTime = CONFIG.policeMaxSearchTime[wantedLevel] || 0;
                
                if (searchDuration > maxSearchTime && distance > CONFIG.policePursueDistance) {
                    despawnPoliceUnit(policeCar, i, 'car');
                    continue;
                }
                
                if (distance < CONFIG.policePursueDistance) {
                    policeCar.searchStartTime = Date.now();
                }
                
                if (distance < CONFIG.policeShootingDistance) {
                    policeCar.state = 'shooting';
                    policeCar.speed = THREE.MathUtils.lerp(policeCar.speed, 0, 0.1);
                    
                    policeShoot(policeCar, playerPos);
                    policeYell(policeCar, distance);
                } else if (distance < CONFIG.policePursueDistance) {
                    policeCar.state = 'pursuing';
                    policePursue(policeCar, playerPos);
                } else {
                    policeCar.state = 'searching';
                    policePursue(policeCar, playerPos); 
                }
                
                updatePoliceSiren(policeCar, deltaTime);
                
                const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), policeCar.mesh.rotation.y);
                policeCar.mesh.position.add(forward.multiplyScalar(policeCar.speed));
            }
            
            for (let i = policeHelicopters.length - 1; i >= 0; i--) {
                const heli = policeHelicopters[i];
                const distance = heli.mesh.position.distanceTo(playerPos);
                const searchDuration = (Date.now() - heli.searchStartTime) / 1000;
                const maxSearchTime = CONFIG.policeMaxSearchTime[wantedLevel] || 0;
                
                if (searchDuration > maxSearchTime && wantedLevel < 5) {
                    despawnPoliceUnit(heli, i, 'helicopter');
                    continue;
                }
                
                heli.mesh.position.x = THREE.MathUtils.lerp(heli.mesh.position.x, playerPos.x, 0.02);
                heli.mesh.position.z = THREE.MathUtils.lerp(heli.mesh.position.z, playerPos.z, 0.02);
                heli.mesh.position.y = CONFIG.policeHelicopterAltitude;
                
                heli.rotor.rotation.y += deltaTime * 20;
                heli.tailRotor.rotation.x += deltaTime * 20;
                
                if (distance < CONFIG.policeShootingDistance * 2) {
                    policeShoot(heli, playerPos);
                }
            }
        }

        function policePursue(policeUnit, targetPos) {
            const direction = new THREE.Vector3().subVectors(targetPos, policeUnit.mesh.position).normalize();
            const targetRotation = Math.atan2(direction.x, direction.z);
            policeUnit.mesh.rotation.y = THREE.MathUtils.lerp(policeUnit.mesh.rotation.y, targetRotation, 0.05);
            policeUnit.speed = THREE.MathUtils.lerp(policeUnit.speed, policeUnit.maxSpeed * 0.9, 0.05);
        }

        function policeShoot(policeUnit, targetPos) {
            const now = Date.now();
            if (now - (policeUnit.lastShotTime || 0) < 1000) return;
            
            policeUnit.lastShotTime = now;
            
            playerHealth = Math.max(0, playerHealth - 8);
            updateHealthUI();
            
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.background = 'rgba(255, 0, 0, 0.2)';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '999';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 100);
        }

        function policeYell(policeCar, distance) {
            const now = Date.now();
            if (now - policeCar.lastYellTime < 3000) return;
            
            policeCar.lastYellTime = now;
            const yell = POLICE_YELLS[policeYellIndex % POLICE_YELLS.length];
            policeYellIndex++;
            
            showFloatingText(policeCar.mesh.position, yell, 'threaten', 3);
        }

        function updatePoliceSiren(policeCar, deltaTime) {
            if (!policeCar.sirenLights) return;
            
            const time = Date.now() * 0.005;
            const flashOn = Math.floor(time) % 2 === 0;
            
            policeCar.sirenLights.red.material.color.setHex(flashOn ? 0xff0000 : 0x330000);
            policeCar.sirenLights.blue.material.color.setHex(flashOn ? 0x0000ff : 0x000033);
        }

        // GTA-STYLE CIRCULAR MINIMAP
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            if (!canvas) return;
            
            canvas.width = 180;
            canvas.height = 180;
            const ctx = canvas.getContext('2d');
            const centerX = 90;
            const centerY = 90;
            const radius = 85;
            
            const playerPos = isInVehicle ? currentVehicle?.mesh.position : playerGroup.position;
            const playerRotation = isInVehicle ? currentVehicle?.mesh.rotation.y : playerGroup.rotation.y;
            
            // Clear with circular clip
            ctx.clearRect(0, 0, 180, 180);
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.clip();
            
            // Background gradient (dark blue-green like GTA)
            const bgGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            bgGrad.addColorStop(0, '#1a3040');
            bgGrad.addColorStop(1, '#0d1820');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, 180, 180);
            
            // Calculate view offset - player centered, map rotates with player
            const worldSize = CONFIG.gridSize * CONFIG.tileSize;
            const viewRadius = 120; // How much world space to show
            const scale = radius / viewRadius;
            
            ctx.translate(centerX, centerY);
            ctx.rotate(-playerRotation + Math.PI); // Rotate map so forward is always up
            ctx.translate(-playerPos.x * scale, -playerPos.z * scale);
            
            // Draw roads (dark gray)
            ctx.fillStyle = '#2a3540';
            roadTiles.forEach(tile => {
                const rx = tile.x * CONFIG.tileSize * scale;
                const rz = tile.z * CONFIG.tileSize * scale;
                ctx.fillRect(rx - CONFIG.tileSize * scale / 2, rz - CONFIG.tileSize * scale / 2, 
                           CONFIG.tileSize * scale, CONFIG.tileSize * scale);
            });
            
            // Draw buildings (darker blocks)
            ctx.fillStyle = '#3d4a55';
            buildings.forEach(building => {
                const bx = ((building.minX + building.maxX) / 2) * scale;
                const bz = ((building.minZ + building.maxZ) / 2) * scale;
                const bw = (building.maxX - building.minX) * scale;
                const bh = (building.maxZ - building.minZ) * scale;
                ctx.fillRect(bx - bw/2, bz - bh/2, bw, bh);
            });
            
            // Draw beach area (sand color) - expanded beach
            ctx.fillStyle = '#8a7a60';
            for (let x = CONFIG.gridSize - 7; x < CONFIG.gridSize; x++) {
                for (let z = 0; z < CONFIG.gridSize; z++) {
                    const sx = x * CONFIG.tileSize * scale;
                    const sz = z * CONFIG.tileSize * scale;
                    ctx.fillRect(sx - CONFIG.tileSize * scale / 2, sz - CONFIG.tileSize * scale / 2,
                               CONFIG.tileSize * scale, CONFIG.tileSize * scale);
                }
            }
            
            // Draw water (beyond beach)
            ctx.fillStyle = '#1a4a6a';
            ctx.fillRect(worldSize * scale, -200, 500, 800);
            
            // Draw traffic cars (white dots)
            ctx.fillStyle = '#ffffff';
            cars.forEach(car => {
                if (car.mesh) {
                    const cx = car.mesh.position.x * scale;
                    const cz = car.mesh.position.z * scale;
                ctx.beginPath();
                    ctx.arc(cx, cz, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw Police (red/blue flashing)
            const flashRed = Math.sin(Date.now() / 150) > 0;
            policeCars.forEach(car => {
                const px = car.mesh.position.x * scale;
                const pz = car.mesh.position.z * scale;
                ctx.fillStyle = flashRed ? '#ff3333' : '#3333ff';
                ctx.beginPath();
                ctx.arc(px, pz, 4, 0, Math.PI * 2);
                ctx.fill();
                // Outer glow
                ctx.strokeStyle = flashRed ? 'rgba(255, 50, 50, 0.5)' : 'rgba(50, 50, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // Draw NPCs (small yellow dots)
            ctx.fillStyle = '#ffcc00';
            npcs.forEach(npc => {
                if (npc.mesh) {
                    const nx = npc.mesh.position.x * scale;
                    const nz = npc.mesh.position.z * scale;
                    ctx.beginPath();
                    ctx.arc(nx, nz, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.restore();
            
            // Draw player marker (always centered, pointing up)
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Player triangle (white with cyan glow)
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(0, -8);
            ctx.lineTo(-5, 6);
            ctx.lineTo(5, 6);
            ctx.closePath();
            ctx.fill();
            
            // Inner detail
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#00ddff';
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(-3, 4);
            ctx.lineTo(3, 4);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Update location text based on player position
            const locationEl = document.getElementById('minimap-location');
            if (locationEl) {
                let area = 'DOWNTOWN';
                if (playerPos.x > worldSize * 0.75) area = 'SUNSET BEACH';
                else if (playerPos.x < worldSize * 0.3 && playerPos.z < worldSize * 0.3) area = 'NORTH DISTRICT';
                else if (playerPos.x < worldSize * 0.3 && playerPos.z > worldSize * 0.7) area = 'SOUTH SIDE';
                else if (playerPos.z < worldSize * 0.3) area = 'INDUSTRIAL';
                else if (playerPos.z > worldSize * 0.7) area = 'HARBOR AREA';
                locationEl.textContent = area;
            }
            
            // Update compass
            const compassEl = document.getElementById('minimap-compass');
            if (compassEl) {
                const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
                let angle = (playerRotation * 180 / Math.PI) % 360;
                if (angle < 0) angle += 360;
                const idx = Math.round(angle / 45) % 8;
                compassEl.textContent = dirs[idx];
            }
        }

        // === NEW HEALTH SYSTEM ===
        function updateHealthUI() {
            const healthPercent = (playerHealth / CONFIG.maxHealth) * 100;
            document.getElementById('health-fill').style.width = healthPercent + '%';
            
            if (playerHealth <= 0) {
                playerDeath();
            }
        }

        function playerDeath() {
            // Reset wanted level FIRST and update UI immediately
            wantedLevel = 0;
            updateWantedStarsUI();
            
            // Remove ALL police immediately
            policeCars.forEach(car => {
                scene.remove(car.mesh);
            });
            policeCars = [];
            
            policeHelicopters.forEach(heli => {
                scene.remove(heli.mesh);
            });
            policeHelicopters = [];
            
            // Lose some cash on death (10%)
            playerCash = Math.floor(playerCash * 0.9);
            updateCashDisplay();
            
            if (isInVehicle) {
                exitVehicle();
            }
            
            // Create GTA-style WASTED screen
            const deathScreen = document.createElement('div');
            deathScreen.id = 'wasted-screen';
            deathScreen.innerHTML = `
                <div class="wasted-overlay"></div>
                <div class="wasted-content">
                    <div class="wasted-text">WASTED</div>
                    <div class="wasted-subtext">You lost $${Math.floor(playerCash * 0.1).toLocaleString()}</div>
                </div>
            `;
            deathScreen.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 10000;
                pointer-events: none;
            `;
            
            // Add styles for the wasted screen
            const style = document.createElement('style');
            style.id = 'wasted-style';
            style.textContent = `
                .wasted-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(ellipse at center, 
                        rgba(80, 0, 0, 0.4) 0%, 
                        rgba(40, 0, 0, 0.7) 50%, 
                        rgba(0, 0, 0, 0.9) 100%);
                    animation: wastedFadeIn 0.5s ease-out forwards;
                }
                
                .wasted-content {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center;
                }
                
                .wasted-text {
                    font-family: 'Pricedown', 'Impact', 'Arial Black', sans-serif;
                    font-size: 120px;
                    font-weight: bold;
                    color: #8B0000;
                    text-shadow: 
                        0 0 20px rgba(139, 0, 0, 0.8),
                        0 0 40px rgba(139, 0, 0, 0.6),
                        0 0 60px rgba(139, 0, 0, 0.4),
                        4px 4px 0 #000,
                        -2px -2px 0 #000,
                        2px -2px 0 #000,
                        -2px 2px 0 #000;
                    letter-spacing: 8px;
                    text-transform: uppercase;
                    animation: wastedTextAppear 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
                    opacity: 0;
                    transform: scale(2);
                }
                
                .wasted-subtext {
                    font-family: 'Segoe UI', Arial, sans-serif;
                    font-size: 24px;
                    color: #ff4444;
                    text-shadow: 2px 2px 4px #000;
                    margin-top: 20px;
                    opacity: 0;
                    animation: wastedSubtextAppear 0.5s ease-out 0.6s forwards;
                }
                
                @keyframes wastedFadeIn {
                    0% { opacity: 0; }
                    100% { opacity: 1; }
                }
                
                @keyframes wastedTextAppear {
                    0% { 
                        opacity: 0; 
                        transform: scale(2);
                        filter: blur(10px);
                    }
                    50% {
                        opacity: 1;
                        filter: blur(0px);
                    }
                    100% { 
                        opacity: 1; 
                        transform: scale(1);
                        filter: blur(0px);
                    }
                }
                
                @keyframes wastedSubtextAppear {
                    0% { opacity: 0; transform: translateY(20px); }
                    100% { opacity: 1; transform: translateY(0); }
                }
                
                @keyframes wastedFadeOut {
                    0% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(deathScreen);
            
            // Respawn after delay
            setTimeout(() => {
                // Respawn on beach - south of theme park, open area
                const beachX = (CONFIG.gridSize - 4) * CONFIG.tileSize;
                const beachZ = (CONFIG.gridSize * 0.5) * CONFIG.tileSize; // Middle of beach
                playerGroup.position.set(beachX, 0, beachZ);
                playerHealth = CONFIG.maxHealth;
                updateHealthUI();
                
                // Double-check police are gone
                wantedLevel = 0;
                updateWantedStarsUI();
                policeCars.forEach(car => scene.remove(car.mesh));
                policeCars = [];
                policeHelicopters.forEach(heli => scene.remove(heli.mesh));
                policeHelicopters = [];
            }, 3000);
            
            // Fade out and remove death screen (longer duration)
            setTimeout(() => {
                deathScreen.style.animation = 'wastedFadeOut 0.8s ease-out forwards';
                setTimeout(() => {
                    deathScreen.remove();
                    const styleEl = document.getElementById('wasted-style');
                    if (styleEl) styleEl.remove();
                }, 800);
            }, 4000);
        }
        
        function updateCashDisplay() {
            const cashEl = document.getElementById('cash-display');
            if (cashEl) {
                cashEl.textContent = '$' + playerCash.toLocaleString();
            }
        }

        // === NEW INVENTORY SYSTEM ===
        let isInventoryOpen = false;
        let currentWeapon = 'Fists';

        const weapons = [
            { name: 'Fists', icon: 'üëä' },
            { name: 'Pistol', icon: 'üî´' },
            { name: 'AK-47', icon: 'üî´' },
            { name: 'Baseball Bat', icon: 'üèè' }
        ];

        function initInventory() {
            const wheel = document.getElementById('inventory-wheel');
            const radius = 150;

            weapons.forEach((weapon, index) => {
                const item = document.createElement('div');
                item.className = 'inventory-item';
                item.innerHTML = weapon.icon;
                item.dataset.name = weapon.name;

                const angle = (index / weapons.length) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                item.style.left = `calc(50% + ${x}px - 40px)`;
                item.style.top = `calc(50% + ${y}px - 40px)`;

                item.addEventListener('click', () => {
                    selectWeapon(weapon.name);
                    toggleInventory();
                });

                wheel.appendChild(item);
            });

            updateWeaponHUD();
        }

        function toggleInventory() {
            isInventoryOpen = !isInventoryOpen;
            const wheel = document.getElementById('inventory-wheel');
            const items = wheel.getElementsByClassName('inventory-item');
            
            if (isInventoryOpen) {
                Array.from(items).forEach(item => {
                    if (item.dataset.name === currentWeapon) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
                wheel.style.display = 'block';
                document.exitPointerLock();
            } else {
                wheel.style.display = 'none';
                document.body.requestPointerLock();
            }
        }

        function selectWeapon(name) {
            currentWeapon = name;
            updateWeaponHUD();
            updateWeaponVisuals();
        }

        function updateWeaponHUD() {
            document.getElementById('current-weapon-hud').textContent = `Weapon: ${currentWeapon}`;
            const stats = WEAPON_STATS[currentWeapon];
            
            const ammoDisplay = document.getElementById('ammo-display');
            if (stats.type === 'gun') {
                ammoDisplay.style.display = 'block';
                document.getElementById('crosshair').style.display = 'block';
            } else {
                ammoDisplay.style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
            }
        }
        
        function updateWeaponVisuals() {
            const stats = WEAPON_STATS[currentWeapon];
            
            if (playerGun) {
                playerGun.visible = (stats.type === 'gun');
                if (stats.color) playerGun.material.color.setHex(stats.color);
            }
            
            const crosshair = document.getElementById('crosshair');
            if (isInVehicle) {
                crosshair.style.display = 'none';
            } else {
                crosshair.style.display = (stats.type === 'gun') ? 'block' : 'none';
            }
        }

        // === CINEMATIC NOCLIP MODE ===
        let noclipNotificationTimeout = null;
        
        function showNoclipNotification(text) {
            let notif = document.getElementById('noclip-notif');
            if (!notif) {
                notif = document.createElement('div');
                notif.id = 'noclip-notif';
                notif.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #00ffff;
                    padding: 20px 40px;
                    font-size: 24px;
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: bold;
                    border: 2px solid #00ffff;
                    border-radius: 10px;
                    z-index: 9999;
                    text-transform: uppercase;
                    letter-spacing: 3px;
                    text-shadow: 0 0 10px #00ffff;
                    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
                `;
                document.body.appendChild(notif);
            }
            notif.textContent = text;
            notif.style.display = 'block';
            
            if (noclipNotificationTimeout) clearTimeout(noclipNotificationTimeout);
            noclipNotificationTimeout = setTimeout(() => {
                notif.style.display = 'none';
            }, 1500);
        }
        
        function updateNoclipCamera(deltaTime) {
            if (!isNoclipMode) return;
            
            // Speed settings: slow = 0.03, ultra slow = 0.015
            const moveSpeed = noclipSpeed === 2 ? 8 : 20;
            const lagFactor = noclipSpeed === 2 ? 0.015 : 0.04; // Lower = more cinematic lag
            
            // Smoothly interpolate camera angles (cinematic lag effect)
            noclipCurrentYaw += (noclipTargetYaw - noclipCurrentYaw) * lagFactor;
            noclipCurrentPitch += (noclipTargetPitch - noclipCurrentPitch) * lagFactor;
            
            // Calculate movement direction based on current camera orientation
            const forward = new THREE.Vector3(
                -Math.sin(noclipCurrentYaw) * Math.cos(noclipCurrentPitch),
                Math.sin(noclipCurrentPitch),
                -Math.cos(noclipCurrentYaw) * Math.cos(noclipCurrentPitch)
            );
            const right = new THREE.Vector3(
                Math.cos(noclipCurrentYaw),
                0,
                -Math.sin(noclipCurrentYaw)
            );
            const up = new THREE.Vector3(0, 1, 0);
            
            // Movement controls
            const actualSpeed = moveSpeed * deltaTime;
            if (keys.w) noclipPosition.add(forward.clone().multiplyScalar(actualSpeed));
            if (keys.s) noclipPosition.add(forward.clone().multiplyScalar(-actualSpeed));
            if (keys.d) noclipPosition.add(right.clone().multiplyScalar(actualSpeed));
            if (keys.a) noclipPosition.add(right.clone().multiplyScalar(-actualSpeed));
            if (keys.space) noclipPosition.add(up.clone().multiplyScalar(actualSpeed));
            if (keys.shift) noclipPosition.add(up.clone().multiplyScalar(-actualSpeed));
            
            // Apply smooth camera position and rotation
            camera.position.lerp(noclipPosition, lagFactor * 2);
            
            // Calculate look target
            const lookTarget = new THREE.Vector3(
                camera.position.x - Math.sin(noclipCurrentYaw) * Math.cos(noclipCurrentPitch),
                camera.position.y + Math.sin(noclipCurrentPitch),
                camera.position.z - Math.cos(noclipCurrentYaw) * Math.cos(noclipCurrentPitch)
            );
            camera.lookAt(lookTarget);
        }

        // --- BALANCED ANIMATION LOOP ---
        let lastTime = 0;
        let frameCount = 0;
        
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            frameCount++;
            
            if (deltaTime > 0.1 || deltaTime <= 0) return;
            
            // Noclip camera mode - keep the world alive while in cinematic view
            if (isNoclipMode) {
                updateNoclipCamera(deltaTime);
                updateOcean(); // Keep ocean animated
                updateThemeParkRides(deltaTime); // Keep theme park rides animated
                updateNPCs(deltaTime); // Keep NPCs walking
                updateTrafficLights(deltaTime); // Keep traffic lights cycling
                cars.forEach(car => updateCarAI(car, deltaTime)); // Keep cars driving
                renderer.render(scene, camera);
                return; // Skip player controls in noclip mode
            }
            
            // Player/vehicle controls - every frame
            if (!isInVehicle) {
                updatePlayer(deltaTime);
            } else {
                updateVehicleControls(deltaTime);
            }
            
            // Traffic lights - every frame
            updateTrafficLights(deltaTime);
            
            // Ocean waves - every frame for smooth animation
            updateOcean();
            
            // Theme park rides animation - every frame
            updateThemeParkRides(deltaTime);
            
            // Car AI - every frame
            cars.forEach(car => {
                updateCarAI(car, deltaTime);
            });
            
            // NPCs - every frame
            updateNPCs(deltaTime);
            
            // Police - every 2 frames
            if (wantedLevel > 0 && frameCount % 2 === 0) {
                spawnPolice();
                updatePoliceAI(deltaTime * 2);
            }
            
            // Minimap - every 2 frames
            if (frameCount % 2 === 0) {
            updateMinimap();
            }
            
            // Clock - every 60 frames
            if (frameCount % 60 === 0) {
            const date = new Date();
            document.getElementById('clock').innerText = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => {
            updateHealthUI();
        });

        init();

    </script>
</body>
</html>
